{"version":3,"file":"leaflet-lasso.umd.min.js","sources":["../src/lasso-polygon.ts","../node_modules/@terraformer/spatial/dist/t-spatial.esm.js","../src/calc.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/lasso-handler.ts","../src/lasso-control.ts","../src/index.ts"],"sourcesContent":["import * as L from 'leaflet';\nimport * as GeoJSON from 'geojson';\n\nexport class LassoPolygon extends L.Layer {\n    readonly polyline: L.Polyline;\n    readonly polygon: L.Polygon;\n\n    constructor(latlngs: L.LatLngExpression[], options?: L.PolylineOptions) {\n        super();\n\n        this.polyline = L.polyline(latlngs, options);\n        this.polygon = L.polygon(latlngs, { ...options, weight: 0 });\n    }\n\n    onAdd(map: L.Map): this {\n        this.polyline.addTo(map);\n        this.polygon.addTo(map);\n\n        return this;\n    }\n\n    onRemove(): this {\n        this.polyline.remove();\n        this.polygon.remove();\n\n        return this;\n    }\n\n    addLatLng(latlng: L.LatLngExpression): this {\n        this.polyline.addLatLng(latlng);\n        this.polygon.addLatLng(latlng);\n\n        return this;\n    }\n\n    getLatLngs(): L.LatLng[] {\n        return this.polygon.getLatLngs()[0] as L.LatLng[];\n    }\n\n    toGeoJSON(): GeoJSON.Feature<GeoJSON.Polygon> {\n        return this.polygon.toGeoJSON() as GeoJSON.Feature<GeoJSON.Polygon>;\n    }\n}","/* @preserve\n* @terraformer/spatial - v2.1.1 - MIT\n* Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.\n* Tue Aug 02 2022 14:23:50 GMT-0700 (Pacific Daylight Time)\n*/\n/*\nInternal: Calculate an bounding box from an nested array of positions\n[\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n]\n*/\nvar calculateBoundsFromNestedArrays = function calculateBoundsFromNestedArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i];\n\n    for (var j = 0; j < inner.length; j++) {\n      var lonlat = inner[j];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of arrays of arrays\n[\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n]\n*/\n\n\nvar calculateBoundsFromNestedArrayOfArrays = function calculateBoundsFromNestedArrayOfArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i]; // return calculateBoundsFromNestedArrays(inner); // more DRY?\n\n    for (var j = 0; j < inner.length; j++) {\n      var innerinner = inner[j];\n\n      for (var k = 0; k < innerinner.length; k++) {\n        var lonlat = innerinner[k];\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of positions\n[\n  [lng, lat],[lng, lat],[lng, lat]\n]\n*/\n\n\nvar calculateBoundsFromArray = function calculateBoundsFromArray(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var lonlat = array[i];\n    var lon = lonlat[0];\n    var lat = lonlat[1];\n\n    if (x1 === null) {\n      x1 = lon;\n    } else if (lon < x1) {\n      x1 = lon;\n    }\n\n    if (x2 === null) {\n      x2 = lon;\n    } else if (lon > x2) {\n      x2 = lon;\n    }\n\n    if (y1 === null) {\n      y1 = lat;\n    } else if (lat < y1) {\n      y1 = lat;\n    }\n\n    if (y2 === null) {\n      y2 = lat;\n    } else if (lat > y2) {\n      y2 = lat;\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate an bounding box for a feature collection\n*/\n\n\nvar calculateBoundsForFeatureCollection = function calculateBoundsForFeatureCollection(featureCollection) {\n  var extents = [];\n\n  for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(featureCollection.features[i].geometry);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n/*\nInternal: Calculate an bounding box for a geometry collection\n*/\n\n\nvar calculateBoundsForGeometryCollection = function calculateBoundsForGeometryCollection(geometryCollection) {\n  var extents = [];\n\n  for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(geometryCollection.geometries[i]);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n\nvar calculateBounds = function calculateBounds(geojson) {\n  if (geojson.type) {\n    switch (geojson.type) {\n      case 'Point':\n        return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n      case 'MultiPoint':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'LineString':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'MultiLineString':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'Polygon':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'MultiPolygon':\n        return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n      case 'Feature':\n        return geojson.geometry ? calculateBounds(geojson.geometry) : null;\n\n      case 'FeatureCollection':\n        return calculateBoundsForFeatureCollection(geojson);\n\n      case 'GeometryCollection':\n        return calculateBoundsForGeometryCollection(geojson);\n\n      default:\n        throw new Error('Unknown type: ' + geojson.type);\n    }\n  }\n\n  return null;\n};\n\nvar EARTH_RADIUS = 6378137;\nvar DEGREES_PER_RADIAN = 57.295779513082320;\nvar RADIANS_PER_DEGREE = 0.017453292519943;\nvar MercatorCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/sr-org/6928/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\nvar GeographicCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/epsg/4326/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\n\n/*\nInternal: Convert radians to degrees. Used by spatial reference converters.\n*/\n\nvar radToDeg = function radToDeg(rad) {\n  return rad * DEGREES_PER_RADIAN;\n};\n/*\nInternal: Convert degrees to radians. Used by spatial reference converters.\n*/\n\nvar degToRad = function degToRad(deg) {\n  return deg * RADIANS_PER_DEGREE;\n};\nvar positionToGeographic = function positionToGeographic(position) {\n  var x = position[0];\n  var y = position[1];\n  return [radToDeg(x / EARTH_RADIUS) - Math.floor((radToDeg(x / EARTH_RADIUS) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EARTH_RADIUS)))];\n};\nvar positionToMercator = function positionToMercator(position) {\n  var lng = position[0];\n  var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n  return [degToRad(lng) * EARTH_RADIUS, EARTH_RADIUS / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];\n};\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nvar isNumber = function isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar arraysIntersectArrays = function arraysIntersectArrays(a, b) {\n  if (isNumber(a[0][0])) {\n    if (isNumber(b[0][0])) {\n      for (var i = 0; i < a.length - 1; i++) {\n        for (var j = 0; j < b.length - 1; j++) {\n          if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var k = 0; k < b.length; k++) {\n        if (arraysIntersectArrays(a, b[k])) {\n          return true;\n        }\n      }\n    }\n  } else {\n    for (var l = 0; l < a.length; l++) {\n      if (arraysIntersectArrays(a[l], b)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/*\nInternal: used for sorting\n*/\n\nvar compSort = function compSort(p1, p2) {\n  if (p1[0] > p2[0]) {\n    return -1;\n  } else if (p1[0] < p2[0]) {\n    return 1;\n  } else if (p1[1] > p2[1]) {\n    return -1;\n  } else if (p1[1] < p2[1]) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: -1,0,1 comparison function\n  */\n\nvar cmp = function cmp(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: used to determine turn\n  */\n\n\nvar turn = function turn(p, q, r) {\n  // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n  return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n};\n/*\n  Internal: used to determine euclidean distance between two points\n  */\n\n\nvar euclideanDistance = function euclideanDistance(p, q) {\n  // Returns the squared Euclidean distance between p and q.\n  var dx = q[0] - p[0];\n  var dy = q[1] - p[1];\n  return dx * dx + dy * dy;\n};\n\nvar nextHullPoint = function nextHullPoint(points, p) {\n  // Returns the next point on the convex hull in CCW from p.\n  var q = p;\n\n  for (var r in points) {\n    var t = turn(p, q, points[r]);\n\n    if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n      q = points[r];\n    }\n  }\n\n  return q;\n};\n\nvar coordinateConvexHull = function coordinateConvexHull(points) {\n  // implementation of the Jarvis March algorithm\n  // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n  if (points.length === 0) {\n    return [];\n  } else if (points.length === 1) {\n    return points;\n  } // Returns the points on the convex hull of points in CCW order.\n\n\n  var hull = [points.sort(compSort)[0]];\n\n  for (var p = 0; p < hull.length; p++) {\n    var q = nextHullPoint(points, hull[p]);\n\n    if (q !== hull[0]) {\n      hull.push(q);\n    }\n  }\n\n  return hull;\n};\n/*\nInternal: Returns a copy of coordinates for a closed polygon\n*/\n\nvar closedPolygon = function closedPolygon(coordinates) {\n  var outer = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var inner = coordinates[i].slice();\n\n    if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n      inner.push(inner[0]);\n    }\n\n    outer.push(inner);\n  }\n\n  return outer;\n};\n/*\nInternal: safe warning\n*/\n\nfunction warn() {\n  var args = Array.prototype.slice.apply(arguments);\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn.apply(console, args);\n  }\n}\n/*\nInternal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n*/\n\nvar eachPosition = function eachPosition(coordinates, func) {\n  for (var i = 0; i < coordinates.length; i++) {\n    // we found a number so lets convert the pair\n    if (typeof coordinates[i][0] === 'number') {\n      coordinates[i] = func(coordinates[i]);\n    } // we found an coordinates array it again and run the function against it\n\n\n    if (_typeof(coordinates[i]) === 'object') {\n      coordinates[i] = eachPosition(coordinates[i], func);\n    }\n  }\n\n  return coordinates;\n};\n/*\nApply a function agaist all positions in a geojson object. Used by spatial reference converters.\n*/\n\n\nvar applyConverter = function applyConverter(geojson, converter, noCrs) {\n  if (geojson.type === 'Point') {\n    geojson.coordinates = converter(geojson.coordinates);\n  } else if (geojson.type === 'Feature') {\n    geojson.geometry = applyConverter(geojson.geometry, converter, true);\n  } else if (geojson.type === 'FeatureCollection') {\n    for (var f = 0; f < geojson.features.length; f++) {\n      geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n    }\n  } else if (geojson.type === 'GeometryCollection') {\n    for (var g = 0; g < geojson.geometries.length; g++) {\n      geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n    }\n  } else {\n    geojson.coordinates = eachPosition(geojson.coordinates, converter);\n  }\n\n  if (!noCrs) {\n    if (converter === positionToMercator) {\n      geojson.crs = MercatorCRS;\n    }\n  }\n\n  if (converter === positionToGeographic) {\n    delete geojson.crs;\n  }\n\n  return geojson;\n};\nvar coordinatesEqual = function coordinatesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var na = a.slice().sort(compSort);\n  var nb = b.slice().sort(compSort);\n\n  for (var i = 0; i < na.length; i++) {\n    if (na[i].length !== nb[i].length) {\n      return false;\n    }\n\n    for (var j = 0; j < na.length; j++) {\n      if (na[i][j] !== nb[i][j]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar convexHull = function convexHull(geojson) {\n  var coordinates = [];\n  var i;\n  var j;\n\n  if (geojson.type === 'Point') {\n    return null;\n  } else if (geojson.type === 'LineString' || geojson.type === 'MultiPoint') {\n    if (geojson.coordinates && geojson.coordinates.length >= 3) {\n      coordinates = geojson.coordinates;\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Polygon' || geojson.type === 'MultiLineString') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        coordinates = coordinates.concat(geojson.coordinates[i]);\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'MultiPolygon') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        for (j = 0; j < geojson.coordinates[i].length; j++) {\n          coordinates = coordinates.concat(geojson.coordinates[i][j]);\n        }\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Feature') {\n    return convexHull(geojson.geometry);\n  }\n\n  return {\n    type: 'Polygon',\n    coordinates: closedPolygon([coordinateConvexHull(coordinates)])\n  };\n};\nvar isConvex = function isConvex(points) {\n  var ltz;\n\n  for (var i = 0; i < points.length - 3; i++) {\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n    var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n\n    var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n    if (i === 0) {\n      if (res < 0) {\n        ltz = true;\n      } else {\n        ltz = false;\n      }\n    } else {\n      if (ltz && res > 0 || !ltz && res < 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar polygonContainsPoint = function polygonContainsPoint(polygon, point) {\n  if (polygon && polygon.length) {\n    if (polygon.length === 1) {\n      // polygon with no holes\n      return coordinatesContainPoint(polygon[0], point);\n    } else {\n      // polygon with holes\n      if (coordinatesContainPoint(polygon[0], point)) {\n        for (var i = 1; i < polygon.length; i++) {\n          if (coordinatesContainPoint(polygon[i], point)) {\n            return false; // found in hole\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n};\n\nvar within = function within(geoJSON, comparisonGeoJSON) {\n  var coordinates, i, contains; // if we are passed a feature, use the polygon inside instead\n\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  } // point.within(point) :: equality\n\n\n  if (comparisonGeoJSON.type === 'Point') {\n    if (geoJSON.type === 'Point') {\n      return pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n    }\n  } // point.within(multilinestring)\n\n\n  if (comparisonGeoJSON.type === 'MultiLineString') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var linestring = {\n          type: 'LineString',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, linestring)) {\n          return true;\n        }\n      }\n    }\n  } // point.within(linestring), point.within(multipoint)\n\n\n  if (comparisonGeoJSON.type === 'LineString' || comparisonGeoJSON.type === 'MultiPoint') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        if (geoJSON.coordinates.length !== comparisonGeoJSON.coordinates[i].length) {\n          return false;\n        }\n\n        if (pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates[i])) {\n          return true;\n        }\n      }\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'Polygon') {\n    // polygon.within(polygon)\n    if (geoJSON.type === 'Polygon') {\n      // check for equal polygons\n      if (comparisonGeoJSON.coordinates.length === geoJSON.coordinates.length) {\n        for (i = 0; i < geoJSON.coordinates.length; i++) {\n          if (coordinatesEqual(geoJSON.coordinates[i], comparisonGeoJSON.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n\n      if (geoJSON.coordinates.length && polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[0][0])) {\n        return !arraysIntersectArrays(closedPolygon(geoJSON.coordinates), closedPolygon(comparisonGeoJSON.coordinates));\n      } else {\n        return false;\n      } // point.within(polygon)\n\n    } else if (geoJSON.type === 'Point') {\n      return polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates); // linestring/multipoint withing polygon\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      if (!geoJSON.coordinates || geoJSON.coordinates.length === 0) {\n        return false;\n      }\n\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[i]) === false) {\n          return false;\n        }\n      }\n\n      return true; // multilinestring.within(polygon)\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(ls, comparisonGeoJSON) === false) {\n          contains++;\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(polygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var p1 = {\n          type: 'Polygon',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(p1, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'MultiPolygon') {\n    // point.within(multipolygon)\n    if (geoJSON.type === 'Point') {\n      if (comparisonGeoJSON.coordinates.length) {\n        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n          coordinates = comparisonGeoJSON.coordinates[i];\n\n          if (polygonContainsPoint(coordinates, geoJSON.coordinates) && arraysIntersectArrays([geoJSON.coordinates], comparisonGeoJSON.coordinates) === false) {\n            return true;\n          }\n        }\n      }\n\n      return false; // polygon.within(multipolygon)\n    } else if (geoJSON.type === 'Polygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (comparisonGeoJSON.coordinates[i].length === geoJSON.coordinates.length) {\n          for (var j = 0; j < geoJSON.coordinates.length; j++) {\n            if (coordinatesEqual(geoJSON.coordinates[j], comparisonGeoJSON.coordinates[i][j])) {\n              return true;\n            }\n          }\n        }\n      }\n\n      if (arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates) === false) {\n        if (comparisonGeoJSON.coordinates.length) {\n          for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n            coordinates = comparisonGeoJSON.coordinates[i];\n\n            if (polygonContainsPoint(coordinates, geoJSON.coordinates[0][0]) === false) {\n              contains = false;\n            } else {\n              contains = true;\n            }\n          }\n\n          return contains;\n        }\n      } // linestring.within(multipolygon), multipoint.within(multipolygon)\n\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var poly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, poly)) {\n          return true;\n        }\n\n        return false;\n      } // multilinestring.within(multipolygon)\n\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var _ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(_ls, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(multipolygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var mpoly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, mpoly) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } // default to false\n\n\n  return false;\n};\n\nvar contains = function contains(geoJSON, comparisonGeoJSON) {\n  return within(comparisonGeoJSON, geoJSON);\n};\n\nvar intersects = function intersects(geoJSON, comparisonGeoJSON) {\n  // if we are passed a feature, use the polygon inside instead\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  }\n\n  if (within(geoJSON, comparisonGeoJSON) || within(comparisonGeoJSON, geoJSON)) {\n    return true;\n  }\n\n  if (geoJSON.type === 'MultiPolygon' && multipolygonIntersection(geoJSON, comparisonGeoJSON)) {\n    return true;\n  }\n\n  if (geoJSON.type !== 'Point' && geoJSON.type !== 'MultiPoint' && comparisonGeoJSON.type !== 'Point' && comparisonGeoJSON.type !== 'MultiPoint') {\n    return arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n  } else if (geoJSON.type === 'Feature') {\n    // in the case of a Feature, use the internal geometry for intersection\n    var inner = geoJSON.geometry;\n    return intersects(inner, comparisonGeoJSON);\n  }\n\n  warn('Type ' + geoJSON.type + ' to ' + comparisonGeoJSON.type + ' intersection is not supported by intersects');\n  return false;\n};\n\nfunction multipolygonIntersection(geoJSON, comparisonGeoJSON) {\n  return geoJSON.coordinates.some(function (coordinates) {\n    var componentPolygon = {\n      type: 'Polygon',\n      coordinates: coordinates\n    };\n    return within(componentPolygon, comparisonGeoJSON) || within(comparisonGeoJSON, componentPolygon);\n  });\n}\n\nvar VINCENTY = {\n  a: 6378137,\n  b: 6356752.3142,\n  f: 1 / 298.257223563\n};\nvar toGeographic = function toGeographic(geojson) {\n  return applyConverter(geojson, positionToGeographic);\n};\nvar toCircle = function toCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var rad = radius || 250;\n\n  if (!center || center.length < 2 || !rad || !steps) {\n    throw new Error('Terraformer: missing parameter for Terraformer.Circle');\n  }\n\n  return {\n    type: 'Feature',\n    geometry: createGeodesicCircle(center, rad, steps),\n    properties: {\n      radius: rad,\n      center: center,\n      steps: steps\n    }\n  };\n};\n/* cribbed from\n  http://stackoverflow.com/questions/24145205/writing-a-function-to-convert-a-circle-to-a-polygon-using-leaflet-js\n*/\n\nvar createGeodesicCircle = function createGeodesicCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var polygon = {\n    type: 'Polygon',\n    coordinates: [[]]\n  };\n  var angle;\n\n  for (var i = 0; i < steps; i++) {\n    angle = i * 360 / steps;\n    polygon.coordinates[0].push(destinationVincenty(center, angle, radius));\n  }\n\n  polygon.coordinates = closedPolygon(polygon.coordinates);\n  return polygon;\n};\n\nvar destinationVincenty = function destinationVincenty(coords, brng, dist) {\n  var cos2SigmaM, sinSigma, cosSigma, deltaSigma;\n  var a = VINCENTY.a;\n  var b = VINCENTY.b;\n  var f = VINCENTY.f;\n  var lon1 = coords[0];\n  var lat1 = coords[1];\n  var s = dist;\n  var pi = Math.PI;\n  var alpha1 = brng * pi / 180; // converts brng degrees to radius\n\n  var sinAlpha1 = Math.sin(alpha1);\n  var cosAlpha1 = Math.cos(alpha1);\n  var tanU1 = (1 - f) * Math.tan(lat1 * pi / 180\n  /* converts lat1 degrees to radius */\n  );\n  var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);\n  var sinU1 = tanU1 * cosU1;\n  var sigma1 = Math.atan2(tanU1, cosAlpha1);\n  var sinAlpha = cosU1 * sinAlpha1;\n  var cosSqAlpha = 1 - sinAlpha * sinAlpha;\n  var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n  var sigma = s / (b * A);\n  var sigmaP = 2 * Math.PI;\n\n  while (Math.abs(sigma - sigmaP) > 1e-12) {\n    cos2SigmaM = Math.cos(2 * sigma1 + sigma);\n    sinSigma = Math.sin(sigma);\n    cosSigma = Math.cos(sigma);\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    sigmaP = sigma;\n    sigma = s / (b * A) + deltaSigma;\n  }\n\n  var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;\n  var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));\n  var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);\n  var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n  var lam = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n  var lamFunc = lon1 + lam * 180 / pi; // converts lam radius to degrees\n\n  var lat2a = lat2 * 180 / pi; // converts lat2a radius to degrees\n\n  return [lamFunc, lat2a];\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * Calculate the envelope surrounding the input.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {Object} Object in the form { x, y, w, h }.\n * ```js\n * import { calculateEnvelope } from \"@terraformer/spatial\"\n *\n * calculateEnvelope({\n *   type: \"Point\",\n *   coordinates: [ 100, 100 ]\n * })\n *\n * >> { x: 100, y: 100, w: 0, h: 0, }\n * ```\n */\n\nvar calculateEnvelope = function calculateEnvelope(geojson) {\n  var bounds = calculateBounds(geojson);\n  return {\n    x: bounds[0],\n    y: bounds[1],\n    w: Math.abs(bounds[0] - bounds[2]),\n    h: Math.abs(bounds[1] - bounds[3])\n  };\n};\n/**\n * Reproject WGS84 (Lat/Lng) GeoJSON to Web Mercator.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {object} GeoJSON\n * ```js\n * import { toMercator } from \"@terraformer/spatial\"\n *\n * toMercator({\n *   type: \"Point\",\n *   coordinates: [ 45, 60 ]\n * })\n *\n * >> { type: \"Point\", coordinates: [ -13580978, 5621521 ], crs }\n * ```\n */\n\nvar toMercator = function toMercator(geojson) {\n  return applyConverter(geojson, positionToMercator);\n};\n\nexport { GeographicCRS, MercatorCRS, applyConverter, calculateBounds, calculateEnvelope, contains, convexHull, intersects, isConvex, polygonContainsPoint, positionToGeographic, positionToMercator, toCircle, toGeographic, toMercator, within };\n","import * as L from 'leaflet';\nimport * as GeoJSON from 'geojson';\nimport { calculateBounds, toCircle, contains, intersects } from '@terraformer/spatial';\n\nfunction geoJSONGeometryToBounds(geometry: GeoJSON.GeometryObject) {\n    const bounds = calculateBounds(geometry);\n    const leafletBounds = L.latLngBounds([bounds[1], bounds[0]], [bounds[3], bounds[2]]);\n    return leafletBounds;\n}\n\nfunction getCircleMarkerRadius(circleMarker: L.CircleMarker, crs: L.CRS, zoom: number) {\n    const latLng = circleMarker.getLatLng();\n    const point = crs.latLngToPoint(latLng, zoom);\n    const delta = circleMarker.getRadius() / Math.SQRT2;\n    const topLeftPoint = L.point([point.x - delta, point.y - delta]);\n    const topLeftLatLng = crs.pointToLatLng(topLeftPoint, zoom);\n    const radius = crs.distance(latLng, topLeftLatLng);\n    return radius;\n}\n\nfunction circleToGeoJSONGeometry(latLng: L.LatLng, radius: number) {\n    return toCircle(L.GeoJSON.latLngToCoords(latLng), radius).geometry;\n}\n\nfunction layerToGeoJSONGeometry(layer: L.Layer, options: { zoom?: number, crs?: L.CRS } = {}): GeoJSON.Geometry | undefined {\n    if (layer instanceof L.Circle) {\n        const latLng = layer.getLatLng();\n        const radius = layer.getRadius();\n        return circleToGeoJSONGeometry(latLng, radius);\n    } else if (layer instanceof L.CircleMarker) {\n        if (options.zoom != undefined && options.crs != undefined) {\n            const latLng = layer.getLatLng();\n            const radius = getCircleMarkerRadius(layer, options.crs, options.zoom);\n            return circleToGeoJSONGeometry(latLng, radius);\n        } else {\n            console.warn(\"Zoom and CRS is required for calculating CircleMarker polygon, falling back to center point only\");\n            return layer.toGeoJSON().geometry;\n        }\n    } else if (layer instanceof L.Marker || layer instanceof L.Polyline) {\n        return layer.toGeoJSON().geometry;\n    } else {\n        console.warn(\"Layer GeoJSON geometry is not available\", layer);\n        return undefined;\n    }\n}\n\nfunction polygonContains(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\n    return contains(polygon, layerGeometry);\n}\n\nfunction polygonIntersects(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\n    return layerGeometry.type === \"Point\" ?\n        contains(polygon, layerGeometry) :\n        intersects(polygon, layerGeometry);\n}\n\nexport function getLayersInPolygon(polygon: L.Polygon, layers: L.Layer[], options: { zoom?: number, crs?: L.CRS, intersect?: boolean } = {}) {\n    const polygonGeometry = polygon.toGeoJSON().geometry as GeoJSON.Polygon;\n    const polygonBounds = polygon.getBounds();\n\n    const selectedLayers = layers.filter(layer => {\n        // check bounds first (fast)\n        let layerGeometry;\n        let layerBounds;\n        if (layer instanceof L.Polyline) {\n            layerBounds = layer.getBounds();\n        } else {\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\n            if (layerGeometry) {\n                layerBounds = geoJSONGeometryToBounds(layerGeometry);\n            }\n        }\n\n        // some bounds may be invalid, for example for empty polylines\n        if (!layerBounds || !layerBounds.isValid()) {\n            return false;\n        }\n\n        const boundsResult = options.intersect ?\n            polygonBounds.intersects(layerBounds) :\n            polygonBounds.contains(layerBounds);\n        if (!boundsResult) {\n            return false;\n        }\n\n        // check full geometry (slow)\n        if (!layerGeometry) {\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\n        }\n        if (!layerGeometry) {\n            return false;\n        }\n\n        const geometryResult = options.intersect ?\n            polygonIntersects(polygonGeometry, layerGeometry) :\n            polygonContains(polygonGeometry, layerGeometry);\n        return geometryResult;\n    });\n    \n    return selectedLayers;\n}","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import * as L from 'leaflet';\nimport { LassoPolygon } from './lasso-polygon';\nimport { getLayersInPolygon } from './calc';\nimport './lasso-handler.css';\n\nexport interface LassoHandlerOptions {\n    polygon?: L.PolylineOptions,\n    intersect?: boolean;\n}\n\ninterface LassoHandlerFinishedEventData {\n    originalEvent: MouseEvent;\n    latLngs: L.LatLng[];\n    layers: L.Layer[];\n}\n\nexport type LassoHandlerFinishedEvent = L.LeafletEvent & LassoHandlerFinishedEventData;\n\nexport const ENABLED_EVENT = 'lasso.enabled';\nexport const DISABLED_EVENT = 'lasso.disabled';\nexport const FINISHED_EVENT = 'lasso.finished';\n\nexport const ACTIVE_CLASS = 'leaflet-lasso-active';\n\nexport class LassoHandler extends L.Handler {\n    options: LassoHandlerOptions = {\n        polygon: {\n            color: '#00C3FF',\n            weight: 2,\n        },\n        intersect: false,\n    };\n\n    private map: L.Map;\n\n    private polygon?: LassoPolygon;\n\n    private onMapMouseDownBound = this.onMapMouseDown.bind(this);\n    private onDocumentMouseMoveBound = this.onDocumentMouseMove.bind(this);\n    private onDocumentMouseUpBound = this.onDocumentMouseUp.bind(this);\n\n    constructor(map: L.Map, options: LassoHandlerOptions = {}) {\n        super(map);\n        \n        this.map = map;\n        L.Util.setOptions(this, options);\n    }\n\n    setOptions(options: LassoHandlerOptions) {\n        this.options = { ...this.options, ...options };\n    }\n\n    toggle() {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable();\n        }\n    }\n    \n    addHooks() {\n        this.map.getPane('mapPane');\n        this.map.getContainer().addEventListener('mousedown', this.onMapMouseDownBound);\n        this.map.getContainer().addEventListener('touchstart', this.onMapMouseDownBound);\n        \n        const mapContainer = this.map.getContainer();\n        mapContainer.classList.add(ACTIVE_CLASS);\n\n        this.map.dragging.disable();\n        this.map.fire(ENABLED_EVENT);\n    }\n\n    removeHooks() {\n        if (this.polygon) {\n            this.map.removeLayer(this.polygon);\n            this.polygon = undefined;\n        }\n\n        this.map.getContainer().removeEventListener('mousedown', this.onMapMouseDownBound);\n        this.map.getContainer().removeEventListener('touchstart', this.onMapMouseDownBound);\n        document.removeEventListener('mousemove', this.onDocumentMouseMoveBound);\n        document.removeEventListener('touchmove', this.onDocumentMouseMoveBound);\n        document.removeEventListener('mouseup', this.onDocumentMouseUpBound);\n        document.removeEventListener('touchend', this.onDocumentMouseUpBound);\n\n        this.map.getContainer().classList.remove(ACTIVE_CLASS);\n        document.body.classList.remove(ACTIVE_CLASS);\n\n        this.map.dragging.enable();\n        this.map.fire(DISABLED_EVENT);\n    }\n\n    private onMapMouseDown(event: Event) {\n        event.stopPropagation();\n        \n        let event2 = this.eventToMouseEvent('down', event);\n        if (!event2) {\n            return;\n        }\n\n        // activate lasso only for left mouse button click\n        if (event instanceof MouseEvent && !(event as any)._simulated && event.buttons !== 1) {\n            this.disable();\n            return;\n        }\n\n        // skip clicks on controls\n        if ((event.target as HTMLElement).closest('.leaflet-control-container')) {\n            return;\n        }\n\n        const latLng = this.map.mouseEventToLatLng(event2);\n        this.polygon = new LassoPolygon([latLng], this.options.polygon).addTo(this.map);\n\n        document.body.classList.add(ACTIVE_CLASS);\n\n        document.addEventListener('mousemove', this.onDocumentMouseMoveBound);\n        document.addEventListener('touchmove', this.onDocumentMouseMoveBound);\n        document.addEventListener('mouseup', this.onDocumentMouseUpBound);\n        document.addEventListener('touchend', this.onDocumentMouseUpBound);\n\n        event.preventDefault();\n    }\n\n    private onDocumentMouseMove(event: Event) {\n        event.stopPropagation();\n        \n        let event2 = this.eventToMouseEvent('move', event);\n        if (!event2) {\n            return;\n        }\n\n        if (!this.polygon) {\n            return;\n        }\n\n        // keep lasso active only if left mouse button is hold\n        if (event instanceof MouseEvent && !(event as any)._simulated && event.buttons !== 1) {\n            // warning disabled as it causes confusion and the cause is unclear\n            // console.warn('mouseup event was missed');\n            this.finish(event);\n            return;\n        }\n\n        const latLng = this.map.mouseEventToLatLng(event2);\n        this.polygon.addLatLng(latLng);\n\n        event.preventDefault();\n    }\n\n    private onDocumentMouseUp(event: MouseEvent | TouchEvent) {\n        this.finish(event);\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    private eventToMouseEvent(type: string, event: Event) {\n        if (event instanceof MouseEvent) {\n            return event;\n        }\n        if (event instanceof TouchEvent && event.touches.length === 1) {\n            return new MouseEvent(type, {\n                screenX: event.touches[0].screenX,\n                screenY: event.touches[0].screenY,\n                clientX: event.touches[0].clientX,\n                clientY: event.touches[0].clientY,\n                buttons: 1,\n            });\n        }\n    }\n\n    private finish(event: MouseEvent | TouchEvent) {\n        if (!this.polygon) {\n            return;\n        }\n\n        const layers: L.Layer[] = [];\n        this.map.eachLayer(layer => {\n            if (layer === this.polygon || layer === this.polygon!.polyline || layer === this.polygon!.polygon) {\n                return;\n            }\n\n            if (L.MarkerCluster && layer instanceof L.MarkerCluster) {\n                layers.push(...layer.getAllChildMarkers());\n            } else if (layer instanceof L.Marker || layer instanceof L.Path) {\n                layers.push(layer);\n            }\n        });\n\n        const selectedFeatures = getLayersInPolygon(this.polygon.polygon, layers, {\n            zoom: this.map.getZoom(),\n            crs: this.map.options.crs,\n            intersect: this.options.intersect,\n        });\n\n        this.map.fire(FINISHED_EVENT, {\n            originalEvent: event,\n            latLngs: this.polygon.getLatLngs(),\n            layers: selectedFeatures,\n        } as LassoHandlerFinishedEventData);\n\n        this.disable();\n    }\n}\n","import * as L from 'leaflet';\nimport { LassoHandler, LassoHandlerOptions } from './lasso-handler';\nimport './lasso-control.css';\n\nexport interface LassoControlOptionsData  {\n    title?: string;\n}\n\nexport type LassoControlOptions = L.ControlOptions & LassoControlOptionsData & LassoHandlerOptions;\n\nexport class LassoControl extends L.Control {\n    options: LassoControlOptions = {\n        position: 'topright',\n        title: 'Toggle Lasso'\n    };\n\n    private lasso?: LassoHandler;\n\n    constructor(options: LassoControlOptions = {}) {\n        super();\n\n        L.Util.setOptions(this, options);\n    }\n\n    setOptions(options: LassoControlOptions) {\n        this.options = { ...this.options, ...options };\n        \n        if (this.lasso) {\n            this.lasso.setOptions(this.options);\n        }\n    }\n\n    onAdd(map: L.Map) {\n        this.lasso = new LassoHandler(map, this.options);\n\n        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control') as HTMLDivElement;\n        const button = L.DomUtil.create('a', 'leaflet-control-lasso', container) as HTMLAnchorElement;\n        button.href = 'javascript:void(0)';\n        button.title = this.options.title!;\n        button.setAttribute('role', 'button');\n        button.setAttribute('aria-label', button.title);\n\n        L.DomEvent.addListener(button, 'click', this.toggle, this);\n        L.DomEvent.disableClickPropagation(button);\n\n        return container;\n    }\n\n    enabled() {\n        if (!this.lasso) {\n            return false;\n        }\n        return this.lasso.enabled();\n    }\n\n    enable() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.enable();\n    }\n\n    disable() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.disable();\n    }\n\n    toggle() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.toggle();\n    }\n}\n","import 'leaflet';\nimport { LassoHandler } from './lasso-handler';\nimport { LassoControl } from './lasso-control';\n\ndeclare module 'leaflet' {\n    type Lasso = LassoHandler;\n    let Lasso: typeof LassoHandler;\n\n    let lasso: (...args: ConstructorParameters<typeof LassoHandler>) => LassoHandler;\n    \n    namespace Control {\n        type Lasso = LassoControl;\n        let Lasso: typeof LassoControl;\n    }\n\n    namespace control {\n        let lasso: (...args: ConstructorParameters<typeof LassoControl>) => LassoControl;\n    }\n}\n\nif (typeof window.L !== 'undefined') {\n    window.L.Lasso = LassoHandler;\n    window.L.lasso = (...args: ConstructorParameters<typeof LassoHandler>) => new LassoHandler(...args);\n\n    window.L.Control.Lasso = LassoControl;\n    window.L.control.lasso = (...args: ConstructorParameters<typeof LassoControl>) => new LassoControl(...args);\n}\n\nexport * from './lasso-handler';\nexport * from './lasso-control';"],"names":["LassoPolygon","_super","latlngs","options","_this","this","polyline","L","polygon","__assign","weight","__extends","prototype","onAdd","map","addTo","onRemove","remove","addLatLng","latlng","getLatLngs","toGeoJSON","Layer","calculateBoundsFromNestedArrays","array","x1","x2","y1","y2","i","length","inner","j","lonlat","lon","lat","calculateBoundsFromArray","calculateBoundsForFeatureCollection","featureCollection","extents","features","extent","calculateBounds","geometry","push","calculateBoundsForGeometryCollection","geometryCollection","geometries","geojson","type","coordinates","innerinner","k","calculateBoundsFromNestedArrayOfArrays","Error","isNumber","n","isNaN","parseFloat","isFinite","edgeIntersectsEdge","a1","a2","b1","b2","uaT","ubT","uB","ua","ub","arraysIntersectArrays","a","b","l","coordinatesContainPoint","point","contains","pointsEqual","compSort","p1","p2","closedPolygon","outer","slice","coordinatesEqual","na","sort","nb","polygonContainsPoint","within","geoJSON","comparisonGeoJSON","intersects","some","componentPolygon","multipolygonIntersection","args","Array","apply","arguments","console","warn","VINCENTY","toCircle","center","radius","interpolate","steps","rad","createGeodesicCircle","properties","angle","destinationVincenty","coords","brng","dist","cos2SigmaM","sinSigma","cosSigma","f","lon1","lat1","s","pi","Math","PI","alpha1","sinAlpha1","sin","cosAlpha1","cos","tanU1","tan","cosU1","sqrt","sinU1","sigma1","atan2","sinAlpha","cosSqAlpha","uSq","A","B","sigma","sigmaP","abs","tmp","lat2","C","circleToGeoJSONGeometry","latLng","GeoJSON","latLngToCoords","layerToGeoJSONGeometry","layer","Circle","getLatLng","getRadius","CircleMarker","undefined","zoom","crs","circleMarker","latLngToPoint","delta","SQRT2","topLeftPoint","x","y","topLeftLatLng","pointToLatLng","distance","getCircleMarkerRadius","Marker","Polyline","getLayersInPolygon","layers","polygonGeometry","polygonBounds","getBounds","selectedLayers","filter","layerGeometry","layerBounds","bounds","latLngBounds","isValid","intersect","geometryResult","polygonIntersects","polygonContains","styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","ENABLED_EVENT","DISABLED_EVENT","FINISHED_EVENT","ACTIVE_CLASS","LassoHandler","call","color","onMapMouseDownBound","onMapMouseDown","bind","onDocumentMouseMoveBound","onDocumentMouseMove","onDocumentMouseUpBound","onDocumentMouseUp","Util","setOptions","toggle","enabled","disable","enable","addHooks","getPane","getContainer","addEventListener","classList","add","dragging","fire","removeHooks","removeLayer","removeEventListener","body","event","stopPropagation","event2","eventToMouseEvent","MouseEvent","_simulated","buttons","target","closest","mouseEventToLatLng","preventDefault","finish","TouchEvent","touches","screenX","screenY","clientX","clientY","eachLayer","MarkerCluster","getAllChildMarkers","Path","selectedFeatures","getZoom","originalEvent","latLngs","Handler","LassoControl","position","title","lasso","container","DomUtil","create","button","href","setAttribute","DomEvent","addListener","disableClickPropagation","Control","window","Lasso","_i","__spreadArray","control"],"mappings":"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","x_google_ignoreList":[1,3]}