{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"leaflet\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"leaflet\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).LeafletLasso = {}, t.L);\n}(this, function (t, e) {\n  \"use strict\";\n\n  function o(t) {\n    var e = Object.create(null);\n    return t && Object.keys(t).forEach(function (o) {\n      if (\"default\" !== o) {\n        var n = Object.getOwnPropertyDescriptor(t, o);\n        Object.defineProperty(e, o, n.get ? n : {\n          enumerable: !0,\n          get: function () {\n            return t[o];\n          }\n        });\n      }\n    }), e.default = t, Object.freeze(e);\n  }\n  var n = o(e),\n    r = function (t, e) {\n      return r = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (t, e) {\n        t.__proto__ = e;\n      } || function (t, e) {\n        for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);\n      }, r(t, e);\n    };\n  function i(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Class extends value \" + String(e) + \" is not a constructor or null\");\n    function o() {\n      this.constructor = t;\n    }\n    r(t, e), t.prototype = null === e ? Object.create(e) : (o.prototype = e.prototype, new o());\n  }\n  var s = function () {\n    return s = Object.assign || function (t) {\n      for (var e, o = 1, n = arguments.length; o < n; o++) for (var r in e = arguments[o]) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n      return t;\n    }, s.apply(this, arguments);\n  };\n  function a(t, e, o) {\n    if (o || 2 === arguments.length) for (var n, r = 0, i = e.length; r < i; r++) !n && r in e || (n || (n = Array.prototype.slice.call(e, 0, r)), n[r] = e[r]);\n    return t.concat(n || Array.prototype.slice.call(e));\n  }\n  \"function\" == typeof SuppressedError && SuppressedError;\n  var l = function (t) {\n      function e(e, o) {\n        var r = t.call(this) || this;\n        return r.polyline = n.polyline(e, o), r.polygon = n.polygon(e, s(s({}, o), {\n          weight: 0\n        })), r;\n      }\n      return i(e, t), e.prototype.onAdd = function (t) {\n        return this.polyline.addTo(t), this.polygon.addTo(t), this;\n      }, e.prototype.onRemove = function () {\n        return this.polyline.remove(), this.polygon.remove(), this;\n      }, e.prototype.addLatLng = function (t) {\n        return this.polyline.addLatLng(t), this.polygon.addLatLng(t), this;\n      }, e.prototype.getLatLngs = function () {\n        return this.polygon.getLatLngs()[0];\n      }, e.prototype.toGeoJSON = function () {\n        return this.polygon.toGeoJSON();\n      }, e;\n    }(n.Layer),\n    u = function (t) {\n      for (var e = null, o = null, n = null, r = null, i = 0; i < t.length; i++) for (var s = t[i], a = 0; a < s.length; a++) {\n        var l = s[a],\n          u = l[0],\n          c = l[1];\n        (null === e || u < e) && (e = u), (null === o || u > o) && (o = u), (null === n || c < n) && (n = c), (null === r || c > r) && (r = c);\n      }\n      return [e, n, o, r];\n    },\n    c = function (t) {\n      for (var e = null, o = null, n = null, r = null, i = 0; i < t.length; i++) {\n        var s = t[i],\n          a = s[0],\n          l = s[1];\n        (null === e || a < e) && (e = a), (null === o || a > o) && (o = a), (null === n || l < n) && (n = l), (null === r || l > r) && (r = l);\n      }\n      return [e, n, o, r];\n    },\n    p = function (t) {\n      for (var e = [], o = t.features.length - 1; o >= 0; o--) {\n        var n = d(t.features[o].geometry);\n        e.push([n[0], n[1]]), e.push([n[2], n[3]]);\n      }\n      return c(e);\n    },\n    f = function (t) {\n      for (var e = [], o = t.geometries.length - 1; o >= 0; o--) {\n        var n = d(t.geometries[o]);\n        e.push([n[0], n[1]]), e.push([n[2], n[3]]);\n      }\n      return c(e);\n    },\n    d = function t(e) {\n      if (e.type) switch (e.type) {\n        case \"Point\":\n          return [e.coordinates[0], e.coordinates[1], e.coordinates[0], e.coordinates[1]];\n        case \"MultiPoint\":\n        case \"LineString\":\n          return c(e.coordinates);\n        case \"MultiLineString\":\n        case \"Polygon\":\n          return u(e.coordinates);\n        case \"MultiPolygon\":\n          return function (t) {\n            for (var e = null, o = null, n = null, r = null, i = 0; i < t.length; i++) for (var s = t[i], a = 0; a < s.length; a++) for (var l = s[a], u = 0; u < l.length; u++) {\n              var c = l[u],\n                p = c[0],\n                f = c[1];\n              (null === e || p < e) && (e = p), (null === o || p > o) && (o = p), (null === n || f < n) && (n = f), (null === r || f > r) && (r = f);\n            }\n            return [e, n, o, r];\n          }(e.coordinates);\n        case \"Feature\":\n          return e.geometry ? t(e.geometry) : null;\n        case \"FeatureCollection\":\n          return p(e);\n        case \"GeometryCollection\":\n          return f(e);\n        default:\n          throw new Error(\"Unknown type: \" + e.type);\n      }\n      return null;\n    },\n    h = function (t) {\n      return !isNaN(parseFloat(t)) && isFinite(t);\n    },\n    g = function (t, e, o, n) {\n      var r = (n[0] - o[0]) * (t[1] - o[1]) - (n[1] - o[1]) * (t[0] - o[0]),\n        i = (e[0] - t[0]) * (t[1] - o[1]) - (e[1] - t[1]) * (t[0] - o[0]),\n        s = (n[1] - o[1]) * (e[0] - t[0]) - (n[0] - o[0]) * (e[1] - t[1]);\n      if (0 !== s) {\n        var a = r / s,\n          l = i / s;\n        if (a >= 0 && a <= 1 && l >= 0 && l <= 1) return !0;\n      }\n      return !1;\n    },\n    y = function t(e, o) {\n      if (h(e[0][0])) {\n        if (h(o[0][0])) {\n          for (var n = 0; n < e.length - 1; n++) for (var r = 0; r < o.length - 1; r++) if (g(e[n], e[n + 1], o[r], o[r + 1])) return !0;\n        } else for (var i = 0; i < o.length; i++) if (t(e, o[i])) return !0;\n      } else for (var s = 0; s < e.length; s++) if (t(e[s], o)) return !0;\n      return !1;\n    },\n    v = function (t, e) {\n      for (var o = !1, n = -1, r = t.length, i = r - 1; ++n < r; i = n) (t[n][1] <= e[1] && e[1] < t[i][1] || t[i][1] <= e[1] && e[1] < t[n][1]) && e[0] < (t[i][0] - t[n][0]) * (e[1] - t[n][1]) / (t[i][1] - t[n][1]) + t[n][0] && (o = !o);\n      return o;\n    },\n    m = function (t, e) {\n      for (var o = 0; o < t.length; o++) if (t[o] !== e[o]) return !1;\n      return !0;\n    },\n    M = function (t, e) {\n      return t[0] > e[0] ? -1 : t[0] < e[0] ? 1 : t[1] > e[1] ? -1 : t[1] < e[1] ? 1 : 0;\n    },\n    L = function (t) {\n      for (var e = [], o = 0; o < t.length; o++) {\n        var n = t[o].slice();\n        !1 === m(n[0], n[n.length - 1]) && n.push(n[0]), e.push(n);\n      }\n      return e;\n    };\n  /* @preserve\n      * @terraformer/spatial - v2.1.1 - MIT\n      * Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.\n      * Tue Aug 02 2022 14:23:50 GMT-0700 (Pacific Daylight Time)\n      */\n  var A = function (t, e) {\n      if (t.length !== e.length) return !1;\n      for (var o = t.slice().sort(M), n = e.slice().sort(M), r = 0; r < o.length; r++) {\n        if (o[r].length !== n[r].length) return !1;\n        for (var i = 0; i < o.length; i++) if (o[r][i] !== n[r][i]) return !1;\n      }\n      return !0;\n    },\n    b = function (t, e) {\n      if (t && t.length) {\n        if (1 === t.length) return v(t[0], e);\n        if (v(t[0], e)) {\n          for (var o = 1; o < t.length; o++) if (v(t[o], e)) return !1;\n          return !0;\n        }\n        return !1;\n      }\n      return !1;\n    },\n    E = function t(e, o) {\n      var n, r, i;\n      if (\"Feature\" === o.type && (o = o.geometry), \"Point\" === o.type && \"Point\" === e.type) return m(e.coordinates, o.coordinates);\n      if (\"MultiLineString\" === o.type && \"Point\" === e.type) for (r = 0; r < e.coordinates.length; r++) {\n        if (t(e, {\n          type: \"LineString\",\n          coordinates: o.coordinates[r]\n        })) return !0;\n      }\n      if ((\"LineString\" === o.type || \"MultiPoint\" === o.type) && \"Point\" === e.type) for (r = 0; r < o.coordinates.length; r++) {\n        if (e.coordinates.length !== o.coordinates[r].length) return !1;\n        if (m(e.coordinates, o.coordinates[r])) return !0;\n      }\n      if (\"Polygon\" === o.type) {\n        if (\"Polygon\" === e.type) {\n          if (o.coordinates.length === e.coordinates.length) for (r = 0; r < e.coordinates.length; r++) if (A(e.coordinates[r], o.coordinates[r])) return !0;\n          return !(!e.coordinates.length || !b(o.coordinates, e.coordinates[0][0])) && !y(L(e.coordinates), L(o.coordinates));\n        }\n        if (\"Point\" === e.type) return b(o.coordinates, e.coordinates);\n        if (\"LineString\" === e.type || \"MultiPoint\" === e.type) {\n          if (!e.coordinates || 0 === e.coordinates.length) return !1;\n          for (r = 0; r < e.coordinates.length; r++) if (!1 === b(o.coordinates, e.coordinates[r])) return !1;\n          return !0;\n        }\n        if (\"MultiLineString\" === e.type) {\n          for (r = 0; r < e.coordinates.length; r++) {\n            if (!1 === t({\n              type: \"LineString\",\n              coordinates: e.coordinates[r]\n            }, o)) return i++, !1;\n          }\n          return !0;\n        }\n        if (\"MultiPolygon\" === e.type) {\n          for (r = 0; r < e.coordinates.length; r++) {\n            if (!1 === t({\n              type: \"Polygon\",\n              coordinates: e.coordinates[r]\n            }, o)) return !1;\n          }\n          return !0;\n        }\n      }\n      if (\"MultiPolygon\" === o.type) {\n        if (\"Point\" === e.type) {\n          if (o.coordinates.length) for (r = 0; r < o.coordinates.length; r++) if (n = o.coordinates[r], b(n, e.coordinates) && !1 === y([e.coordinates], o.coordinates)) return !0;\n          return !1;\n        }\n        if (\"Polygon\" === e.type) {\n          for (r = 0; r < e.coordinates.length; r++) if (o.coordinates[r].length === e.coordinates.length) for (var s = 0; s < e.coordinates.length; s++) if (A(e.coordinates[s], o.coordinates[r][s])) return !0;\n          if (!1 === y(e.coordinates, o.coordinates) && o.coordinates.length) {\n            for (r = 0; r < o.coordinates.length; r++) n = o.coordinates[r], i = !1 !== b(n, e.coordinates[0][0]);\n            return i;\n          }\n        } else if (\"LineString\" === e.type || \"MultiPoint\" === e.type) for (r = 0; r < o.coordinates.length; r++) {\n          return !!t(e, {\n            type: \"Polygon\",\n            coordinates: o.coordinates[r]\n          });\n        } else {\n          if (\"MultiLineString\" === e.type) {\n            for (r = 0; r < e.coordinates.length; r++) {\n              if (!1 === t({\n                type: \"LineString\",\n                coordinates: e.coordinates[r]\n              }, o)) return !1;\n            }\n            return !0;\n          }\n          if (\"MultiPolygon\" === e.type) {\n            for (r = 0; r < o.coordinates.length; r++) {\n              if (!1 === t(e, {\n                type: \"Polygon\",\n                coordinates: o.coordinates[r]\n              })) return !1;\n            }\n            return !0;\n          }\n        }\n      }\n      return !1;\n    },\n    P = function (t, e) {\n      return E(e, t);\n    },\n    S = function t(e, o) {\n      return \"Feature\" === o.type && (o = o.geometry), !(!E(e, o) && !E(o, e)) || !(\"MultiPolygon\" !== e.type || !function (t, e) {\n        return t.coordinates.some(function (t) {\n          var o = {\n            type: \"Polygon\",\n            coordinates: t\n          };\n          return E(o, e) || E(e, o);\n        });\n      }(e, o)) || (\"Point\" !== e.type && \"MultiPoint\" !== e.type && \"Point\" !== o.type && \"MultiPoint\" !== o.type ? y(e.coordinates, o.coordinates) : \"Feature\" === e.type ? t(e.geometry, o) : (function () {\n        var t = Array.prototype.slice.apply(arguments);\n        \"undefined\" != typeof console && console.warn && console.warn.apply(console, t);\n      }(\"Type \" + e.type + \" to \" + o.type + \" intersection is not supported by intersects\"), !1));\n    };\n  var w = 6378137,\n    D = 6356752.3142,\n    C = 1 / 298.257223563,\n    B = function (t, e, o) {\n      var n = o || 64,\n        r = e || 250;\n      if (!t || t.length < 2 || !r || !n) throw new Error(\"Terraformer: missing parameter for Terraformer.Circle\");\n      return {\n        type: \"Feature\",\n        geometry: O(t, r, n),\n        properties: {\n          radius: r,\n          center: t,\n          steps: n\n        }\n      };\n    },\n    O = function (t, e, o) {\n      for (var n, r = o || 64, i = {\n          type: \"Polygon\",\n          coordinates: [[]]\n        }, s = 0; s < r; s++) n = 360 * s / r, i.coordinates[0].push(T(t, n, e));\n      return i.coordinates = L(i.coordinates), i;\n    },\n    T = function (t, e, o) {\n      for (var n, r, i, s = w, a = D, l = C, u = t[0], c = t[1], p = o, f = Math.PI, d = e * f / 180, h = Math.sin(d), g = Math.cos(d), y = (1 - l) * Math.tan(c * f / 180), v = 1 / Math.sqrt(1 + y * y), m = y * v, M = Math.atan2(y, g), L = v * h, A = 1 - L * L, b = A * (s * s - a * a) / (a * a), E = 1 + b / 16384 * (4096 + b * (b * (320 - 175 * b) - 768)), P = b / 1024 * (256 + b * (b * (74 - 47 * b) - 128)), S = p / (a * E), B = 2 * Math.PI; Math.abs(S - B) > 1e-12;) n = Math.cos(2 * M + S), B = S, S = p / (a * E) + P * (r = Math.sin(S)) * (n + P / 4 * ((i = Math.cos(S)) * (2 * n * n - 1) - P / 6 * n * (4 * r * r - 3) * (4 * n * n - 3)));\n      var O = m * r - v * i * g,\n        T = Math.atan2(m * i + v * r * g, (1 - l) * Math.sqrt(L * L + O * O)),\n        I = l / 16 * A * (4 + l * (4 - 3 * A));\n      return [u + 180 * (Math.atan2(r * h, v * i - m * r * g) - (1 - I) * l * L * (S + I * r * (n + I * i * (2 * n * n - 1)))) / f, 180 * T / f];\n    };\n  function I(t, e) {\n    return B(n.GeoJSON.latLngToCoords(t), e).geometry;\n  }\n  function U(t, e) {\n    if (void 0 === e && (e = {}), t instanceof n.Circle) return I(o = t.getLatLng(), r = t.getRadius());\n    if (t instanceof n.CircleMarker) {\n      if (null != e.zoom && null != e.crs) {\n        var o = t.getLatLng(),\n          r = function (t, e, o) {\n            var r = t.getLatLng(),\n              i = e.latLngToPoint(r, o),\n              s = t.getRadius() / Math.SQRT2,\n              a = n.point([i.x - s, i.y - s]),\n              l = e.pointToLatLng(a, o);\n            return e.distance(r, l);\n          }(t, e.crs, e.zoom);\n        return I(o, r);\n      }\n      return console.warn(\"Zoom and CRS is required for calculating CircleMarker polygon, falling back to center point only\"), t.toGeoJSON().geometry;\n    }\n    return t instanceof n.Marker || t instanceof n.Polyline ? t.toGeoJSON().geometry : void console.warn(\"Layer GeoJSON geometry is not available\", t);\n  }\n  function k(t, e, o) {\n    void 0 === o && (o = {});\n    var r = t.toGeoJSON().geometry,\n      i = t.getBounds(),\n      s = e.filter(function (t) {\n        var e, s, a;\n        if (t instanceof n.Polyline ? s = t.getBounds() : (e = U(t, o)) && (a = d(e), s = n.latLngBounds([a[1], a[0]], [a[3], a[2]])), !s || !s.isValid()) return !1;\n        if (!(o.intersect ? i.intersects(s) : i.contains(s))) return !1;\n        if (e || (e = U(t, o)), !e) return !1;\n        var l = o.intersect ? function (t, e) {\n          return \"Point\" === e.type ? P(t, e) : S(t, e);\n        }(r, e) : function (t, e) {\n          return P(t, e);\n        }(r, e);\n        return l;\n      });\n    return s;\n  }\n  function R(t, e) {\n    void 0 === e && (e = {});\n    var o = e.insertAt;\n    if (t && \"undefined\" != typeof document) {\n      var n = document.head || document.getElementsByTagName(\"head\")[0],\n        r = document.createElement(\"style\");\n      r.type = \"text/css\", \"top\" === o && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(document.createTextNode(t));\n    }\n  }\n  R(\".leaflet-lasso-active {\\n    cursor: crosshair;\\n    -webkit-user-select: none;\\n       -moz-user-select: none;\\n            user-select: none;\\n}\\n\\n.leaflet-lasso-active .leaflet-interactive {\\n    cursor: crosshair;\\n    pointer-events: none;\\n}\");\n  var N = \"lasso.enabled\",\n    F = \"lasso.disabled\",\n    G = \"lasso.finished\",\n    H = \"leaflet-lasso-active\",\n    Q = function (t) {\n      function e(e, o) {\n        void 0 === o && (o = {});\n        var r = t.call(this, e) || this;\n        return r.options = {\n          polygon: {\n            color: \"#00C3FF\",\n            weight: 2\n          },\n          intersect: !1\n        }, r.onMapMouseDownBound = r.onMapMouseDown.bind(r), r.onDocumentMouseMoveBound = r.onDocumentMouseMove.bind(r), r.onDocumentMouseUpBound = r.onDocumentMouseUp.bind(r), r.map = e, n.Util.setOptions(r, o), r;\n      }\n      return i(e, t), e.prototype.setOptions = function (t) {\n        this.options = s(s({}, this.options), t);\n      }, e.prototype.toggle = function () {\n        this.enabled() ? this.disable() : this.enable();\n      }, e.prototype.addHooks = function () {\n        this.map.getPane(\"mapPane\"), this.map.getContainer().addEventListener(\"mousedown\", this.onMapMouseDownBound), this.map.getContainer().addEventListener(\"touchstart\", this.onMapMouseDownBound), this.map.getContainer().classList.add(H), this.map.dragging.disable(), this.map.fire(N);\n      }, e.prototype.removeHooks = function () {\n        this.polygon && (this.map.removeLayer(this.polygon), this.polygon = void 0), this.map.getContainer().removeEventListener(\"mousedown\", this.onMapMouseDownBound), this.map.getContainer().removeEventListener(\"touchstart\", this.onMapMouseDownBound), document.removeEventListener(\"mousemove\", this.onDocumentMouseMoveBound), document.removeEventListener(\"touchmove\", this.onDocumentMouseMoveBound), document.removeEventListener(\"mouseup\", this.onDocumentMouseUpBound), document.removeEventListener(\"touchend\", this.onDocumentMouseUpBound), this.map.getContainer().classList.remove(H), document.body.classList.remove(H), this.map.dragging.enable(), this.map.fire(F);\n      }, e.prototype.onMapMouseDown = function (t) {\n        t.stopPropagation();\n        var e = this.eventToMouseEvent(\"down\", t);\n        if (e) if (t instanceof MouseEvent && !t._simulated && 1 !== t.buttons) this.disable();else if (!t.target.closest(\".leaflet-control-container\")) {\n          var o = this.map.mouseEventToLatLng(e);\n          this.polygon = new l([o], this.options.polygon).addTo(this.map), document.body.classList.add(H), document.addEventListener(\"mousemove\", this.onDocumentMouseMoveBound), document.addEventListener(\"touchmove\", this.onDocumentMouseMoveBound), document.addEventListener(\"mouseup\", this.onDocumentMouseUpBound), document.addEventListener(\"touchend\", this.onDocumentMouseUpBound), t.preventDefault();\n        }\n      }, e.prototype.onDocumentMouseMove = function (t) {\n        t.stopPropagation();\n        var e = this.eventToMouseEvent(\"move\", t);\n        if (e && this.polygon) if (t instanceof MouseEvent && !t._simulated && 1 !== t.buttons) this.finish(t);else {\n          var o = this.map.mouseEventToLatLng(e);\n          this.polygon.addLatLng(o), t.preventDefault();\n        }\n      }, e.prototype.onDocumentMouseUp = function (t) {\n        this.finish(t), t.stopPropagation(), t.preventDefault();\n      }, e.prototype.eventToMouseEvent = function (t, e) {\n        return e instanceof MouseEvent ? e : e instanceof TouchEvent && 1 === e.touches.length ? new MouseEvent(t, {\n          screenX: e.touches[0].screenX,\n          screenY: e.touches[0].screenY,\n          clientX: e.touches[0].clientX,\n          clientY: e.touches[0].clientY,\n          buttons: 1\n        }) : void 0;\n      }, e.prototype.finish = function (t) {\n        var e = this;\n        if (this.polygon) {\n          var o = [];\n          this.map.eachLayer(function (t) {\n            t !== e.polygon && t !== e.polygon.polyline && t !== e.polygon.polygon && (n.MarkerCluster && t instanceof n.MarkerCluster ? o.push.apply(o, t.getAllChildMarkers()) : (t instanceof n.Marker || t instanceof n.Path) && o.push(t));\n          });\n          var r = k(this.polygon.polygon, o, {\n            zoom: this.map.getZoom(),\n            crs: this.map.options.crs,\n            intersect: this.options.intersect\n          });\n          this.map.fire(G, {\n            originalEvent: t,\n            latLngs: this.polygon.getLatLngs(),\n            layers: r\n          }), this.disable();\n        }\n      }, e;\n    }(n.Handler);\n  R(\".leaflet-control-lasso {\\n    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsSAAALEgHS3X78AAAD6UlEQVR4nO1b7XHbMAwFfP0fdYKqE8QbRJ0gGUEjaAR3A4/gbuBOUHWCKhs4E1SegD06jzmYpWhJpiRKNu58Tix+AA8gCQIQK6Xolml109LfAbgDcAfg5gH4NPQEzJwSkf4kRLR2NKmJqNLfSqlqaH7+4y/0McjML0SUQdinHkO8ApCSiPZKqToogxYFAQBC50T03NDkN74raFzSGtahreSLo+9PALG7mlEXaQD6fMD0BgIp8TkQ0ZaINChpl7ExZoZxK2vcGr8nfXl2ztm5g1twI/Q6KHPvVlFg/DMgJgEAWpWCay3lIYX2zJ1bQFQhAO+i9b2l8VEEd/BSWEooBgUAm5REPvg67AGCrZDdIABgQ6qF1oOu8QBAbK4FwTd4bq23SbXeks/OIPg0f7V5TQRCpz3BNdhamH30wgu+CwFC66VqD5IIByRas/eAYDbGqi8AW+FszEp4ocC6y1KQneW6z+YmvJDDLIVDVwBKdNzPVXghi/FbLjprp4AIM2fi6loMcusal8zN8eXirOp885jNrn/BAlKxnL17GWPj+As8viqlDguwAG3V+hR7JKJvSqmyqd1KmMnrUoQHGaEzX6OVaLAfg6sRyUSeUt+UKxGobDSTmZKR5yIAj/h79IhsDPSRFxg6+ho9AAukpI1IgydGxiY4dSRON+/SXgwAyE1sHbkF79JmeEuaPs91H4DWf+Ffk1nSgDwQ0RH5iUbZqgXcAI0MG/FbKn7f+i5DZo14PabISR/lb0qpjWETXq252LmSsidaCYfh8s0pbnKZuFHuEzNvmNl5MiR9YmmRLYHaxb8VJ3SG+UzD3ZyvwyI/UEPozMoZFE2xTjOADId1yuhGBMLO0raSUSE74HsGgDoPiZULsIISPkFqtUlEuOx0YsiHadeIakTC57bGPW0zAVRiP+yVXJhY+M6JHLFcCtfDvUAoahCseoXW0Wz0Oy1310O5WUQLgmX2ZddEzkffhoc2CJMUQ3h4kzt+v7S4ke/CRKWYaBtBYURmF2tcMda7bC0absWEk5TG4ISyS3Suury1BqAB+XIMIDCv7eAEsUTvHtDQoak8bhPSexSlcXadYBlqHu8p0BMIZRVIti9QeD/Hc/S1hVawgKDuufQDriqVZeYcAjeVyL4BGBc1lcaSKY8dolaYmTXgf0ykKFStcCIKpM33Q8vuR1EcXeEuMkhoDnyWCKB81wGUQV+aEhFaJ/mSlgPwYvyHZ8QN9SlS38RbY3hnYQ/NHyH8KVq0+DdGdCgMS+sRe1ImX8xYvAUw8wGb7Q9c88/2l1sAIEPBlPM0ur85GgEPk9IdgAh4mJTuAETAw3RERP8Ab2Uzgrad13wAAAAASUVORK5CYII=');\\n    background-size: 22px;\\n}\");\n  var X = function (t) {\n    function e(e) {\n      void 0 === e && (e = {});\n      var o = t.call(this) || this;\n      return o.options = {\n        position: \"topright\",\n        title: \"Toggle Lasso\"\n      }, n.Util.setOptions(o, e), o;\n    }\n    return i(e, t), e.prototype.setOptions = function (t) {\n      this.options = s(s({}, this.options), t), this.lasso && this.lasso.setOptions(this.options);\n    }, e.prototype.onAdd = function (t) {\n      this.lasso = new Q(t, this.options);\n      var e = n.DomUtil.create(\"div\", \"leaflet-bar leaflet-control\"),\n        o = n.DomUtil.create(\"a\", \"leaflet-control-lasso\", e);\n      return o.href = \"javascript:void(0)\", o.title = this.options.title, o.setAttribute(\"role\", \"button\"), o.setAttribute(\"aria-label\", o.title), n.DomEvent.addListener(o, \"click\", this.toggle, this), n.DomEvent.disableClickPropagation(o), e;\n    }, e.prototype.enabled = function () {\n      return !!this.lasso && this.lasso.enabled();\n    }, e.prototype.enable = function () {\n      this.lasso && this.lasso.enable();\n    }, e.prototype.disable = function () {\n      this.lasso && this.lasso.disable();\n    }, e.prototype.toggle = function () {\n      this.lasso && this.lasso.toggle();\n    }, e;\n  }(n.Control);\n  void 0 !== window.L && (window.L.Lasso = Q, window.L.lasso = function () {\n    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n    return new (Q.bind.apply(Q, a([void 0], t, !1)))();\n  }, window.L.Control.Lasso = X, window.L.control.lasso = function () {\n    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n    return new (X.bind.apply(X, a([void 0], t, !1)))();\n  }), t.ACTIVE_CLASS = H, t.DISABLED_EVENT = F, t.ENABLED_EVENT = N, t.FINISHED_EVENT = G, t.LassoControl = X, t.LassoHandler = Q;\n});","map":{"version":3,"names":["l","t","e","o","r","call","polyline","n","polygon","s","weight","i","prototype","onAdd","addTo","onRemove","remove","addLatLng","getLatLngs","toGeoJSON","Layer","u","calculateBoundsFromNestedArrays","length","a","c","calculateBoundsFromArray","p","calculateBoundsForFeatureCollection","features","d","geometry","push","f","calculateBoundsForGeometryCollection","geometries","type","coordinates","Error","h","isNumber","isNaN","parseFloat","isFinite","g","edgeIntersectsEdge","y","v","coordinatesContainPoint","m","pointsEqual","M","compSort","L","closedPolygon","slice","A","coordinatesEqual","sort","b","polygonContainsPoint","E","P","contains","S","some","Array","apply","arguments","console","warn","w","D","C","B","toCircle","O","properties","radius","center","steps","createGeodesicCircle","T","destinationVincenty","Math","PI","sin","cos","tan","sqrt","atan2","abs","I","GeoJSON","latLngToCoords","U","Circle","getLatLng","getRadius","CircleMarker","zoom","crs","latLngToPoint","SQRT2","point","x","pointToLatLng","distance","Marker","Polyline","k","getBounds","filter","latLngBounds","isValid","intersect","intersects","R","insertAt","document","head","getElementsByTagName","createElement","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","N","F","G","H","Q","options","color","onMapMouseDownBound","onMapMouseDown","bind","onDocumentMouseMoveBound","onDocumentMouseMove","onDocumentMouseUpBound","onDocumentMouseUp","map","Util","setOptions","toggle","enabled","disable","enable","addHooks","getPane","getContainer","addEventListener","classList","add","dragging","fire","removeHooks","removeLayer","removeEventListener","body","stopPropagation","eventToMouseEvent","MouseEvent","_simulated","buttons","target","closest","mouseEventToLatLng","preventDefault","finish","TouchEvent","touches","screenX","screenY","clientX","clientY","eachLayer","MarkerCluster","getAllChildMarkers","Path","getZoom","originalEvent","latLngs","layers","Handler","X","position","title","lasso","DomUtil","create","href","setAttribute","DomEvent","addListener","disableClickPropagation","Control","window","Lasso","control","ACTIVE_CLASS","DISABLED_EVENT","ENABLED_EVENT","FINISHED_EVENT","LassoControl","LassoHandler"],"sources":["C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\src\\lasso-polygon.ts","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\node_modules\\@terraformer\\spatial\\dist\\t-spatial.esm.js","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\src\\calc.ts","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\node_modules\\style-inject\\dist\\style-inject.es.js","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\src\\lasso-handler.ts","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\src\\lasso-control.ts","C:\\Users\\kylea\\Documents\\GIS Projects\\GEOG778\\kcrest_client\\node_modules\\leaflet-lasso\\src\\index.ts"],"sourcesContent":["import * as L from 'leaflet';\nimport * as GeoJSON from 'geojson';\n\nexport class LassoPolygon extends L.Layer {\n    readonly polyline: L.Polyline;\n    readonly polygon: L.Polygon;\n\n    constructor(latlngs: L.LatLngExpression[], options?: L.PolylineOptions) {\n        super();\n\n        this.polyline = L.polyline(latlngs, options);\n        this.polygon = L.polygon(latlngs, { ...options, weight: 0 });\n    }\n\n    onAdd(map: L.Map): this {\n        this.polyline.addTo(map);\n        this.polygon.addTo(map);\n\n        return this;\n    }\n\n    onRemove(): this {\n        this.polyline.remove();\n        this.polygon.remove();\n\n        return this;\n    }\n\n    addLatLng(latlng: L.LatLngExpression): this {\n        this.polyline.addLatLng(latlng);\n        this.polygon.addLatLng(latlng);\n\n        return this;\n    }\n\n    getLatLngs(): L.LatLng[] {\n        return this.polygon.getLatLngs()[0] as L.LatLng[];\n    }\n\n    toGeoJSON(): GeoJSON.Feature<GeoJSON.Polygon> {\n        return this.polygon.toGeoJSON() as GeoJSON.Feature<GeoJSON.Polygon>;\n    }\n}","/* @preserve\n* @terraformer/spatial - v2.1.1 - MIT\n* Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.\n* Tue Aug 02 2022 14:23:50 GMT-0700 (Pacific Daylight Time)\n*/\n/*\nInternal: Calculate an bounding box from an nested array of positions\n[\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n]\n*/\nvar calculateBoundsFromNestedArrays = function calculateBoundsFromNestedArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i];\n\n    for (var j = 0; j < inner.length; j++) {\n      var lonlat = inner[j];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of arrays of arrays\n[\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n  [ [lng, lat],[lng, lat],[lng, lat] ]\n]\n*/\n\n\nvar calculateBoundsFromNestedArrayOfArrays = function calculateBoundsFromNestedArrayOfArrays(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var inner = array[i]; // return calculateBoundsFromNestedArrays(inner); // more DRY?\n\n    for (var j = 0; j < inner.length; j++) {\n      var innerinner = inner[j];\n\n      for (var k = 0; k < innerinner.length; k++) {\n        var lonlat = innerinner[k];\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate a bounding box from an array of positions\n[\n  [lng, lat],[lng, lat],[lng, lat]\n]\n*/\n\n\nvar calculateBoundsFromArray = function calculateBoundsFromArray(array) {\n  var x1 = null;\n  var x2 = null;\n  var y1 = null;\n  var y2 = null;\n\n  for (var i = 0; i < array.length; i++) {\n    var lonlat = array[i];\n    var lon = lonlat[0];\n    var lat = lonlat[1];\n\n    if (x1 === null) {\n      x1 = lon;\n    } else if (lon < x1) {\n      x1 = lon;\n    }\n\n    if (x2 === null) {\n      x2 = lon;\n    } else if (lon > x2) {\n      x2 = lon;\n    }\n\n    if (y1 === null) {\n      y1 = lat;\n    } else if (lat < y1) {\n      y1 = lat;\n    }\n\n    if (y2 === null) {\n      y2 = lat;\n    } else if (lat > y2) {\n      y2 = lat;\n    }\n  }\n\n  return [x1, y1, x2, y2];\n};\n/*\nInternal: Calculate an bounding box for a feature collection\n*/\n\n\nvar calculateBoundsForFeatureCollection = function calculateBoundsForFeatureCollection(featureCollection) {\n  var extents = [];\n\n  for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(featureCollection.features[i].geometry);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n/*\nInternal: Calculate an bounding box for a geometry collection\n*/\n\n\nvar calculateBoundsForGeometryCollection = function calculateBoundsForGeometryCollection(geometryCollection) {\n  var extents = [];\n\n  for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n    var extent = calculateBounds(geometryCollection.geometries[i]);\n    extents.push([extent[0], extent[1]]);\n    extents.push([extent[2], extent[3]]);\n  }\n\n  return calculateBoundsFromArray(extents);\n};\n\nvar calculateBounds = function calculateBounds(geojson) {\n  if (geojson.type) {\n    switch (geojson.type) {\n      case 'Point':\n        return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n      case 'MultiPoint':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'LineString':\n        return calculateBoundsFromArray(geojson.coordinates);\n\n      case 'MultiLineString':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'Polygon':\n        return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n      case 'MultiPolygon':\n        return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n      case 'Feature':\n        return geojson.geometry ? calculateBounds(geojson.geometry) : null;\n\n      case 'FeatureCollection':\n        return calculateBoundsForFeatureCollection(geojson);\n\n      case 'GeometryCollection':\n        return calculateBoundsForGeometryCollection(geojson);\n\n      default:\n        throw new Error('Unknown type: ' + geojson.type);\n    }\n  }\n\n  return null;\n};\n\nvar EARTH_RADIUS = 6378137;\nvar DEGREES_PER_RADIAN = 57.295779513082320;\nvar RADIANS_PER_DEGREE = 0.017453292519943;\nvar MercatorCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/sr-org/6928/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\nvar GeographicCRS = {\n  type: 'link',\n  properties: {\n    href: 'http://spatialreference.org/ref/epsg/4326/ogcwkt/',\n    type: 'ogcwkt'\n  }\n};\n\n/*\nInternal: Convert radians to degrees. Used by spatial reference converters.\n*/\n\nvar radToDeg = function radToDeg(rad) {\n  return rad * DEGREES_PER_RADIAN;\n};\n/*\nInternal: Convert degrees to radians. Used by spatial reference converters.\n*/\n\nvar degToRad = function degToRad(deg) {\n  return deg * RADIANS_PER_DEGREE;\n};\nvar positionToGeographic = function positionToGeographic(position) {\n  var x = position[0];\n  var y = position[1];\n  return [radToDeg(x / EARTH_RADIUS) - Math.floor((radToDeg(x / EARTH_RADIUS) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EARTH_RADIUS)))];\n};\nvar positionToMercator = function positionToMercator(position) {\n  var lng = position[0];\n  var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n  return [degToRad(lng) * EARTH_RADIUS, EARTH_RADIUS / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];\n};\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nvar isNumber = function isNumber(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {\n  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n  if (uB !== 0) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar arraysIntersectArrays = function arraysIntersectArrays(a, b) {\n  if (isNumber(a[0][0])) {\n    if (isNumber(b[0][0])) {\n      for (var i = 0; i < a.length - 1; i++) {\n        for (var j = 0; j < b.length - 1; j++) {\n          if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var k = 0; k < b.length; k++) {\n        if (arraysIntersectArrays(a, b[k])) {\n          return true;\n        }\n      }\n    }\n  } else {\n    for (var l = 0; l < a.length; l++) {\n      if (arraysIntersectArrays(a[l], b)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\nvar coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {\n  var contains = false;\n\n  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n      contains = !contains;\n    }\n  }\n\n  return contains;\n};\nvar pointsEqual = function pointsEqual(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/*\nInternal: used for sorting\n*/\n\nvar compSort = function compSort(p1, p2) {\n  if (p1[0] > p2[0]) {\n    return -1;\n  } else if (p1[0] < p2[0]) {\n    return 1;\n  } else if (p1[1] > p2[1]) {\n    return -1;\n  } else if (p1[1] < p2[1]) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: -1,0,1 comparison function\n  */\n\nvar cmp = function cmp(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n/*\n  Internal: used to determine turn\n  */\n\n\nvar turn = function turn(p, q, r) {\n  // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n  return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n};\n/*\n  Internal: used to determine euclidean distance between two points\n  */\n\n\nvar euclideanDistance = function euclideanDistance(p, q) {\n  // Returns the squared Euclidean distance between p and q.\n  var dx = q[0] - p[0];\n  var dy = q[1] - p[1];\n  return dx * dx + dy * dy;\n};\n\nvar nextHullPoint = function nextHullPoint(points, p) {\n  // Returns the next point on the convex hull in CCW from p.\n  var q = p;\n\n  for (var r in points) {\n    var t = turn(p, q, points[r]);\n\n    if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n      q = points[r];\n    }\n  }\n\n  return q;\n};\n\nvar coordinateConvexHull = function coordinateConvexHull(points) {\n  // implementation of the Jarvis March algorithm\n  // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n  if (points.length === 0) {\n    return [];\n  } else if (points.length === 1) {\n    return points;\n  } // Returns the points on the convex hull of points in CCW order.\n\n\n  var hull = [points.sort(compSort)[0]];\n\n  for (var p = 0; p < hull.length; p++) {\n    var q = nextHullPoint(points, hull[p]);\n\n    if (q !== hull[0]) {\n      hull.push(q);\n    }\n  }\n\n  return hull;\n};\n/*\nInternal: Returns a copy of coordinates for a closed polygon\n*/\n\nvar closedPolygon = function closedPolygon(coordinates) {\n  var outer = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var inner = coordinates[i].slice();\n\n    if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n      inner.push(inner[0]);\n    }\n\n    outer.push(inner);\n  }\n\n  return outer;\n};\n/*\nInternal: safe warning\n*/\n\nfunction warn() {\n  var args = Array.prototype.slice.apply(arguments);\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn.apply(console, args);\n  }\n}\n/*\nInternal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n*/\n\nvar eachPosition = function eachPosition(coordinates, func) {\n  for (var i = 0; i < coordinates.length; i++) {\n    // we found a number so lets convert the pair\n    if (typeof coordinates[i][0] === 'number') {\n      coordinates[i] = func(coordinates[i]);\n    } // we found an coordinates array it again and run the function against it\n\n\n    if (_typeof(coordinates[i]) === 'object') {\n      coordinates[i] = eachPosition(coordinates[i], func);\n    }\n  }\n\n  return coordinates;\n};\n/*\nApply a function agaist all positions in a geojson object. Used by spatial reference converters.\n*/\n\n\nvar applyConverter = function applyConverter(geojson, converter, noCrs) {\n  if (geojson.type === 'Point') {\n    geojson.coordinates = converter(geojson.coordinates);\n  } else if (geojson.type === 'Feature') {\n    geojson.geometry = applyConverter(geojson.geometry, converter, true);\n  } else if (geojson.type === 'FeatureCollection') {\n    for (var f = 0; f < geojson.features.length; f++) {\n      geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n    }\n  } else if (geojson.type === 'GeometryCollection') {\n    for (var g = 0; g < geojson.geometries.length; g++) {\n      geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n    }\n  } else {\n    geojson.coordinates = eachPosition(geojson.coordinates, converter);\n  }\n\n  if (!noCrs) {\n    if (converter === positionToMercator) {\n      geojson.crs = MercatorCRS;\n    }\n  }\n\n  if (converter === positionToGeographic) {\n    delete geojson.crs;\n  }\n\n  return geojson;\n};\nvar coordinatesEqual = function coordinatesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  var na = a.slice().sort(compSort);\n  var nb = b.slice().sort(compSort);\n\n  for (var i = 0; i < na.length; i++) {\n    if (na[i].length !== nb[i].length) {\n      return false;\n    }\n\n    for (var j = 0; j < na.length; j++) {\n      if (na[i][j] !== nb[i][j]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar convexHull = function convexHull(geojson) {\n  var coordinates = [];\n  var i;\n  var j;\n\n  if (geojson.type === 'Point') {\n    return null;\n  } else if (geojson.type === 'LineString' || geojson.type === 'MultiPoint') {\n    if (geojson.coordinates && geojson.coordinates.length >= 3) {\n      coordinates = geojson.coordinates;\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Polygon' || geojson.type === 'MultiLineString') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        coordinates = coordinates.concat(geojson.coordinates[i]);\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'MultiPolygon') {\n    if (geojson.coordinates && geojson.coordinates.length > 0) {\n      for (i = 0; i < geojson.coordinates.length; i++) {\n        for (j = 0; j < geojson.coordinates[i].length; j++) {\n          coordinates = coordinates.concat(geojson.coordinates[i][j]);\n        }\n      }\n\n      if (coordinates.length < 3) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } else if (geojson.type === 'Feature') {\n    return convexHull(geojson.geometry);\n  }\n\n  return {\n    type: 'Polygon',\n    coordinates: closedPolygon([coordinateConvexHull(coordinates)])\n  };\n};\nvar isConvex = function isConvex(points) {\n  var ltz;\n\n  for (var i = 0; i < points.length - 3; i++) {\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n    var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n\n    var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n    if (i === 0) {\n      if (res < 0) {\n        ltz = true;\n      } else {\n        ltz = false;\n      }\n    } else {\n      if (ltz && res > 0 || !ltz && res < 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nvar polygonContainsPoint = function polygonContainsPoint(polygon, point) {\n  if (polygon && polygon.length) {\n    if (polygon.length === 1) {\n      // polygon with no holes\n      return coordinatesContainPoint(polygon[0], point);\n    } else {\n      // polygon with holes\n      if (coordinatesContainPoint(polygon[0], point)) {\n        for (var i = 1; i < polygon.length; i++) {\n          if (coordinatesContainPoint(polygon[i], point)) {\n            return false; // found in hole\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n  } else {\n    return false;\n  }\n};\n\nvar within = function within(geoJSON, comparisonGeoJSON) {\n  var coordinates, i, contains; // if we are passed a feature, use the polygon inside instead\n\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  } // point.within(point) :: equality\n\n\n  if (comparisonGeoJSON.type === 'Point') {\n    if (geoJSON.type === 'Point') {\n      return pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n    }\n  } // point.within(multilinestring)\n\n\n  if (comparisonGeoJSON.type === 'MultiLineString') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var linestring = {\n          type: 'LineString',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, linestring)) {\n          return true;\n        }\n      }\n    }\n  } // point.within(linestring), point.within(multipoint)\n\n\n  if (comparisonGeoJSON.type === 'LineString' || comparisonGeoJSON.type === 'MultiPoint') {\n    if (geoJSON.type === 'Point') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        if (geoJSON.coordinates.length !== comparisonGeoJSON.coordinates[i].length) {\n          return false;\n        }\n\n        if (pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates[i])) {\n          return true;\n        }\n      }\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'Polygon') {\n    // polygon.within(polygon)\n    if (geoJSON.type === 'Polygon') {\n      // check for equal polygons\n      if (comparisonGeoJSON.coordinates.length === geoJSON.coordinates.length) {\n        for (i = 0; i < geoJSON.coordinates.length; i++) {\n          if (coordinatesEqual(geoJSON.coordinates[i], comparisonGeoJSON.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n\n      if (geoJSON.coordinates.length && polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[0][0])) {\n        return !arraysIntersectArrays(closedPolygon(geoJSON.coordinates), closedPolygon(comparisonGeoJSON.coordinates));\n      } else {\n        return false;\n      } // point.within(polygon)\n\n    } else if (geoJSON.type === 'Point') {\n      return polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates); // linestring/multipoint withing polygon\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      if (!geoJSON.coordinates || geoJSON.coordinates.length === 0) {\n        return false;\n      }\n\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[i]) === false) {\n          return false;\n        }\n      }\n\n      return true; // multilinestring.within(polygon)\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(ls, comparisonGeoJSON) === false) {\n          contains++;\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(polygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var p1 = {\n          type: 'Polygon',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(p1, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  if (comparisonGeoJSON.type === 'MultiPolygon') {\n    // point.within(multipolygon)\n    if (geoJSON.type === 'Point') {\n      if (comparisonGeoJSON.coordinates.length) {\n        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n          coordinates = comparisonGeoJSON.coordinates[i];\n\n          if (polygonContainsPoint(coordinates, geoJSON.coordinates) && arraysIntersectArrays([geoJSON.coordinates], comparisonGeoJSON.coordinates) === false) {\n            return true;\n          }\n        }\n      }\n\n      return false; // polygon.within(multipolygon)\n    } else if (geoJSON.type === 'Polygon') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        if (comparisonGeoJSON.coordinates[i].length === geoJSON.coordinates.length) {\n          for (var j = 0; j < geoJSON.coordinates.length; j++) {\n            if (coordinatesEqual(geoJSON.coordinates[j], comparisonGeoJSON.coordinates[i][j])) {\n              return true;\n            }\n          }\n        }\n      }\n\n      if (arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates) === false) {\n        if (comparisonGeoJSON.coordinates.length) {\n          for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n            coordinates = comparisonGeoJSON.coordinates[i];\n\n            if (polygonContainsPoint(coordinates, geoJSON.coordinates[0][0]) === false) {\n              contains = false;\n            } else {\n              contains = true;\n            }\n          }\n\n          return contains;\n        }\n      } // linestring.within(multipolygon), multipoint.within(multipolygon)\n\n    } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var poly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, poly)) {\n          return true;\n        }\n\n        return false;\n      } // multilinestring.within(multipolygon)\n\n    } else if (geoJSON.type === 'MultiLineString') {\n      for (i = 0; i < geoJSON.coordinates.length; i++) {\n        var _ls = {\n          type: 'LineString',\n          coordinates: geoJSON.coordinates[i]\n        };\n\n        if (within(_ls, comparisonGeoJSON) === false) {\n          return false;\n        }\n      }\n\n      return true; // multipolygon.within(multipolygon)\n    } else if (geoJSON.type === 'MultiPolygon') {\n      for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {\n        var mpoly = {\n          type: 'Polygon',\n          coordinates: comparisonGeoJSON.coordinates[i]\n        };\n\n        if (within(geoJSON, mpoly) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } // default to false\n\n\n  return false;\n};\n\nvar contains = function contains(geoJSON, comparisonGeoJSON) {\n  return within(comparisonGeoJSON, geoJSON);\n};\n\nvar intersects = function intersects(geoJSON, comparisonGeoJSON) {\n  // if we are passed a feature, use the polygon inside instead\n  if (comparisonGeoJSON.type === 'Feature') {\n    comparisonGeoJSON = comparisonGeoJSON.geometry;\n  }\n\n  if (within(geoJSON, comparisonGeoJSON) || within(comparisonGeoJSON, geoJSON)) {\n    return true;\n  }\n\n  if (geoJSON.type === 'MultiPolygon' && multipolygonIntersection(geoJSON, comparisonGeoJSON)) {\n    return true;\n  }\n\n  if (geoJSON.type !== 'Point' && geoJSON.type !== 'MultiPoint' && comparisonGeoJSON.type !== 'Point' && comparisonGeoJSON.type !== 'MultiPoint') {\n    return arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates);\n  } else if (geoJSON.type === 'Feature') {\n    // in the case of a Feature, use the internal geometry for intersection\n    var inner = geoJSON.geometry;\n    return intersects(inner, comparisonGeoJSON);\n  }\n\n  warn('Type ' + geoJSON.type + ' to ' + comparisonGeoJSON.type + ' intersection is not supported by intersects');\n  return false;\n};\n\nfunction multipolygonIntersection(geoJSON, comparisonGeoJSON) {\n  return geoJSON.coordinates.some(function (coordinates) {\n    var componentPolygon = {\n      type: 'Polygon',\n      coordinates: coordinates\n    };\n    return within(componentPolygon, comparisonGeoJSON) || within(comparisonGeoJSON, componentPolygon);\n  });\n}\n\nvar VINCENTY = {\n  a: 6378137,\n  b: 6356752.3142,\n  f: 1 / 298.257223563\n};\nvar toGeographic = function toGeographic(geojson) {\n  return applyConverter(geojson, positionToGeographic);\n};\nvar toCircle = function toCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var rad = radius || 250;\n\n  if (!center || center.length < 2 || !rad || !steps) {\n    throw new Error('Terraformer: missing parameter for Terraformer.Circle');\n  }\n\n  return {\n    type: 'Feature',\n    geometry: createGeodesicCircle(center, rad, steps),\n    properties: {\n      radius: rad,\n      center: center,\n      steps: steps\n    }\n  };\n};\n/* cribbed from\n  http://stackoverflow.com/questions/24145205/writing-a-function-to-convert-a-circle-to-a-polygon-using-leaflet-js\n*/\n\nvar createGeodesicCircle = function createGeodesicCircle(center, radius, interpolate) {\n  var steps = interpolate || 64;\n  var polygon = {\n    type: 'Polygon',\n    coordinates: [[]]\n  };\n  var angle;\n\n  for (var i = 0; i < steps; i++) {\n    angle = i * 360 / steps;\n    polygon.coordinates[0].push(destinationVincenty(center, angle, radius));\n  }\n\n  polygon.coordinates = closedPolygon(polygon.coordinates);\n  return polygon;\n};\n\nvar destinationVincenty = function destinationVincenty(coords, brng, dist) {\n  var cos2SigmaM, sinSigma, cosSigma, deltaSigma;\n  var a = VINCENTY.a;\n  var b = VINCENTY.b;\n  var f = VINCENTY.f;\n  var lon1 = coords[0];\n  var lat1 = coords[1];\n  var s = dist;\n  var pi = Math.PI;\n  var alpha1 = brng * pi / 180; // converts brng degrees to radius\n\n  var sinAlpha1 = Math.sin(alpha1);\n  var cosAlpha1 = Math.cos(alpha1);\n  var tanU1 = (1 - f) * Math.tan(lat1 * pi / 180\n  /* converts lat1 degrees to radius */\n  );\n  var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);\n  var sinU1 = tanU1 * cosU1;\n  var sigma1 = Math.atan2(tanU1, cosAlpha1);\n  var sinAlpha = cosU1 * sinAlpha1;\n  var cosSqAlpha = 1 - sinAlpha * sinAlpha;\n  var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n  var sigma = s / (b * A);\n  var sigmaP = 2 * Math.PI;\n\n  while (Math.abs(sigma - sigmaP) > 1e-12) {\n    cos2SigmaM = Math.cos(2 * sigma1 + sigma);\n    sinSigma = Math.sin(sigma);\n    cosSigma = Math.cos(sigma);\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n    sigmaP = sigma;\n    sigma = s / (b * A) + deltaSigma;\n  }\n\n  var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;\n  var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));\n  var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);\n  var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n  var lam = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n  var lamFunc = lon1 + lam * 180 / pi; // converts lam radius to degrees\n\n  var lat2a = lat2 * 180 / pi; // converts lat2a radius to degrees\n\n  return [lamFunc, lat2a];\n};\n\n/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * Calculate the envelope surrounding the input.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {Object} Object in the form { x, y, w, h }.\n * ```js\n * import { calculateEnvelope } from \"@terraformer/spatial\"\n *\n * calculateEnvelope({\n *   type: \"Point\",\n *   coordinates: [ 100, 100 ]\n * })\n *\n * >> { x: 100, y: 100, w: 0, h: 0, }\n * ```\n */\n\nvar calculateEnvelope = function calculateEnvelope(geojson) {\n  var bounds = calculateBounds(geojson);\n  return {\n    x: bounds[0],\n    y: bounds[1],\n    w: Math.abs(bounds[0] - bounds[2]),\n    h: Math.abs(bounds[1] - bounds[3])\n  };\n};\n/**\n * Reproject WGS84 (Lat/Lng) GeoJSON to Web Mercator.\n * @function\n * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.\n * @return {object} GeoJSON\n * ```js\n * import { toMercator } from \"@terraformer/spatial\"\n *\n * toMercator({\n *   type: \"Point\",\n *   coordinates: [ 45, 60 ]\n * })\n *\n * >> { type: \"Point\", coordinates: [ -13580978, 5621521 ], crs }\n * ```\n */\n\nvar toMercator = function toMercator(geojson) {\n  return applyConverter(geojson, positionToMercator);\n};\n\nexport { GeographicCRS, MercatorCRS, applyConverter, calculateBounds, calculateEnvelope, contains, convexHull, intersects, isConvex, polygonContainsPoint, positionToGeographic, positionToMercator, toCircle, toGeographic, toMercator, within };\n","import * as L from 'leaflet';\nimport * as GeoJSON from 'geojson';\nimport { calculateBounds, toCircle, contains, intersects } from '@terraformer/spatial';\n\nfunction geoJSONGeometryToBounds(geometry: GeoJSON.GeometryObject) {\n    const bounds = calculateBounds(geometry);\n    const leafletBounds = L.latLngBounds([bounds[1], bounds[0]], [bounds[3], bounds[2]]);\n    return leafletBounds;\n}\n\nfunction getCircleMarkerRadius(circleMarker: L.CircleMarker, crs: L.CRS, zoom: number) {\n    const latLng = circleMarker.getLatLng();\n    const point = crs.latLngToPoint(latLng, zoom);\n    const delta = circleMarker.getRadius() / Math.SQRT2;\n    const topLeftPoint = L.point([point.x - delta, point.y - delta]);\n    const topLeftLatLng = crs.pointToLatLng(topLeftPoint, zoom);\n    const radius = crs.distance(latLng, topLeftLatLng);\n    return radius;\n}\n\nfunction circleToGeoJSONGeometry(latLng: L.LatLng, radius: number) {\n    return toCircle(L.GeoJSON.latLngToCoords(latLng), radius).geometry;\n}\n\nfunction layerToGeoJSONGeometry(layer: L.Layer, options: { zoom?: number, crs?: L.CRS } = {}): GeoJSON.Geometry | undefined {\n    if (layer instanceof L.Circle) {\n        const latLng = layer.getLatLng();\n        const radius = layer.getRadius();\n        return circleToGeoJSONGeometry(latLng, radius);\n    } else if (layer instanceof L.CircleMarker) {\n        if (options.zoom != undefined && options.crs != undefined) {\n            const latLng = layer.getLatLng();\n            const radius = getCircleMarkerRadius(layer, options.crs, options.zoom);\n            return circleToGeoJSONGeometry(latLng, radius);\n        } else {\n            console.warn(\"Zoom and CRS is required for calculating CircleMarker polygon, falling back to center point only\");\n            return layer.toGeoJSON().geometry;\n        }\n    } else if (layer instanceof L.Marker || layer instanceof L.Polyline) {\n        return layer.toGeoJSON().geometry;\n    } else {\n        console.warn(\"Layer GeoJSON geometry is not available\", layer);\n        return undefined;\n    }\n}\n\nfunction polygonContains(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\n    return contains(polygon, layerGeometry);\n}\n\nfunction polygonIntersects(polygon: GeoJSON.Polygon, layerGeometry: GeoJSON.GeometryObject) {\n    return layerGeometry.type === \"Point\" ?\n        contains(polygon, layerGeometry) :\n        intersects(polygon, layerGeometry);\n}\n\nexport function getLayersInPolygon(polygon: L.Polygon, layers: L.Layer[], options: { zoom?: number, crs?: L.CRS, intersect?: boolean } = {}) {\n    const polygonGeometry = polygon.toGeoJSON().geometry as GeoJSON.Polygon;\n    const polygonBounds = polygon.getBounds();\n\n    const selectedLayers = layers.filter(layer => {\n        // check bounds first (fast)\n        let layerGeometry;\n        let layerBounds;\n        if (layer instanceof L.Polyline) {\n            layerBounds = layer.getBounds();\n        } else {\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\n            if (layerGeometry) {\n                layerBounds = geoJSONGeometryToBounds(layerGeometry);\n            }\n        }\n\n        // some bounds may be invalid, for example for empty polylines\n        if (!layerBounds || !layerBounds.isValid()) {\n            return false;\n        }\n\n        const boundsResult = options.intersect ?\n            polygonBounds.intersects(layerBounds) :\n            polygonBounds.contains(layerBounds);\n        if (!boundsResult) {\n            return false;\n        }\n\n        // check full geometry (slow)\n        if (!layerGeometry) {\n            layerGeometry = layerToGeoJSONGeometry(layer, options);\n        }\n        if (!layerGeometry) {\n            return false;\n        }\n\n        const geometryResult = options.intersect ?\n            polygonIntersects(polygonGeometry, layerGeometry) :\n            polygonContains(polygonGeometry, layerGeometry);\n        return geometryResult;\n    });\n    \n    return selectedLayers;\n}","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import * as L from 'leaflet';\nimport { LassoPolygon } from './lasso-polygon';\nimport { getLayersInPolygon } from './calc';\nimport './lasso-handler.css';\n\nexport interface LassoHandlerOptions {\n    polygon?: L.PolylineOptions,\n    intersect?: boolean;\n}\n\ninterface LassoHandlerFinishedEventData {\n    originalEvent: MouseEvent;\n    latLngs: L.LatLng[];\n    layers: L.Layer[];\n}\n\nexport type LassoHandlerFinishedEvent = L.LeafletEvent & LassoHandlerFinishedEventData;\n\nexport const ENABLED_EVENT = 'lasso.enabled';\nexport const DISABLED_EVENT = 'lasso.disabled';\nexport const FINISHED_EVENT = 'lasso.finished';\n\nexport const ACTIVE_CLASS = 'leaflet-lasso-active';\n\nexport class LassoHandler extends L.Handler {\n    options: LassoHandlerOptions = {\n        polygon: {\n            color: '#00C3FF',\n            weight: 2,\n        },\n        intersect: false,\n    };\n\n    private map: L.Map;\n\n    private polygon?: LassoPolygon;\n\n    private onMapMouseDownBound = this.onMapMouseDown.bind(this);\n    private onDocumentMouseMoveBound = this.onDocumentMouseMove.bind(this);\n    private onDocumentMouseUpBound = this.onDocumentMouseUp.bind(this);\n\n    constructor(map: L.Map, options: LassoHandlerOptions = {}) {\n        super(map);\n        \n        this.map = map;\n        L.Util.setOptions(this, options);\n    }\n\n    setOptions(options: LassoHandlerOptions) {\n        this.options = { ...this.options, ...options };\n    }\n\n    toggle() {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable();\n        }\n    }\n    \n    addHooks() {\n        this.map.getPane('mapPane');\n        this.map.getContainer().addEventListener('mousedown', this.onMapMouseDownBound);\n        this.map.getContainer().addEventListener('touchstart', this.onMapMouseDownBound);\n        \n        const mapContainer = this.map.getContainer();\n        mapContainer.classList.add(ACTIVE_CLASS);\n\n        this.map.dragging.disable();\n        this.map.fire(ENABLED_EVENT);\n    }\n\n    removeHooks() {\n        if (this.polygon) {\n            this.map.removeLayer(this.polygon);\n            this.polygon = undefined;\n        }\n\n        this.map.getContainer().removeEventListener('mousedown', this.onMapMouseDownBound);\n        this.map.getContainer().removeEventListener('touchstart', this.onMapMouseDownBound);\n        document.removeEventListener('mousemove', this.onDocumentMouseMoveBound);\n        document.removeEventListener('touchmove', this.onDocumentMouseMoveBound);\n        document.removeEventListener('mouseup', this.onDocumentMouseUpBound);\n        document.removeEventListener('touchend', this.onDocumentMouseUpBound);\n\n        this.map.getContainer().classList.remove(ACTIVE_CLASS);\n        document.body.classList.remove(ACTIVE_CLASS);\n\n        this.map.dragging.enable();\n        this.map.fire(DISABLED_EVENT);\n    }\n\n    private onMapMouseDown(event: Event) {\n        event.stopPropagation();\n        \n        let event2 = this.eventToMouseEvent('down', event);\n        if (!event2) {\n            return;\n        }\n\n        // activate lasso only for left mouse button click\n        if (event instanceof MouseEvent && !(event as any)._simulated && event.buttons !== 1) {\n            this.disable();\n            return;\n        }\n\n        // skip clicks on controls\n        if ((event.target as HTMLElement).closest('.leaflet-control-container')) {\n            return;\n        }\n\n        const latLng = this.map.mouseEventToLatLng(event2);\n        this.polygon = new LassoPolygon([latLng], this.options.polygon).addTo(this.map);\n\n        document.body.classList.add(ACTIVE_CLASS);\n\n        document.addEventListener('mousemove', this.onDocumentMouseMoveBound);\n        document.addEventListener('touchmove', this.onDocumentMouseMoveBound);\n        document.addEventListener('mouseup', this.onDocumentMouseUpBound);\n        document.addEventListener('touchend', this.onDocumentMouseUpBound);\n\n        event.preventDefault();\n    }\n\n    private onDocumentMouseMove(event: Event) {\n        event.stopPropagation();\n        \n        let event2 = this.eventToMouseEvent('move', event);\n        if (!event2) {\n            return;\n        }\n\n        if (!this.polygon) {\n            return;\n        }\n\n        // keep lasso active only if left mouse button is hold\n        if (event instanceof MouseEvent && !(event as any)._simulated && event.buttons !== 1) {\n            // warning disabled as it causes confusion and the cause is unclear\n            // console.warn('mouseup event was missed');\n            this.finish(event);\n            return;\n        }\n\n        const latLng = this.map.mouseEventToLatLng(event2);\n        this.polygon.addLatLng(latLng);\n\n        event.preventDefault();\n    }\n\n    private onDocumentMouseUp(event: MouseEvent | TouchEvent) {\n        this.finish(event);\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    private eventToMouseEvent(type: string, event: Event) {\n        if (event instanceof MouseEvent) {\n            return event;\n        }\n        if (event instanceof TouchEvent && event.touches.length === 1) {\n            return new MouseEvent(type, {\n                screenX: event.touches[0].screenX,\n                screenY: event.touches[0].screenY,\n                clientX: event.touches[0].clientX,\n                clientY: event.touches[0].clientY,\n                buttons: 1,\n            });\n        }\n    }\n\n    private finish(event: MouseEvent | TouchEvent) {\n        if (!this.polygon) {\n            return;\n        }\n\n        const layers: L.Layer[] = [];\n        this.map.eachLayer(layer => {\n            if (layer === this.polygon || layer === this.polygon!.polyline || layer === this.polygon!.polygon) {\n                return;\n            }\n\n            if (L.MarkerCluster && layer instanceof L.MarkerCluster) {\n                layers.push(...layer.getAllChildMarkers());\n            } else if (layer instanceof L.Marker || layer instanceof L.Path) {\n                layers.push(layer);\n            }\n        });\n\n        const selectedFeatures = getLayersInPolygon(this.polygon.polygon, layers, {\n            zoom: this.map.getZoom(),\n            crs: this.map.options.crs,\n            intersect: this.options.intersect,\n        });\n\n        this.map.fire(FINISHED_EVENT, {\n            originalEvent: event,\n            latLngs: this.polygon.getLatLngs(),\n            layers: selectedFeatures,\n        } as LassoHandlerFinishedEventData);\n\n        this.disable();\n    }\n}\n","import * as L from 'leaflet';\nimport { LassoHandler, LassoHandlerOptions } from './lasso-handler';\nimport './lasso-control.css';\n\nexport interface LassoControlOptionsData  {\n    title?: string;\n}\n\nexport type LassoControlOptions = L.ControlOptions & LassoControlOptionsData & LassoHandlerOptions;\n\nexport class LassoControl extends L.Control {\n    options: LassoControlOptions = {\n        position: 'topright',\n        title: 'Toggle Lasso'\n    };\n\n    private lasso?: LassoHandler;\n\n    constructor(options: LassoControlOptions = {}) {\n        super();\n\n        L.Util.setOptions(this, options);\n    }\n\n    setOptions(options: LassoControlOptions) {\n        this.options = { ...this.options, ...options };\n        \n        if (this.lasso) {\n            this.lasso.setOptions(this.options);\n        }\n    }\n\n    onAdd(map: L.Map) {\n        this.lasso = new LassoHandler(map, this.options);\n\n        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control') as HTMLDivElement;\n        const button = L.DomUtil.create('a', 'leaflet-control-lasso', container) as HTMLAnchorElement;\n        button.href = 'javascript:void(0)';\n        button.title = this.options.title!;\n        button.setAttribute('role', 'button');\n        button.setAttribute('aria-label', button.title);\n\n        L.DomEvent.addListener(button, 'click', this.toggle, this);\n        L.DomEvent.disableClickPropagation(button);\n\n        return container;\n    }\n\n    enabled() {\n        if (!this.lasso) {\n            return false;\n        }\n        return this.lasso.enabled();\n    }\n\n    enable() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.enable();\n    }\n\n    disable() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.disable();\n    }\n\n    toggle() {\n        if (!this.lasso) {\n            return;\n        }\n        this.lasso.toggle();\n    }\n}\n","import 'leaflet';\nimport { LassoHandler } from './lasso-handler';\nimport { LassoControl } from './lasso-control';\n\ndeclare module 'leaflet' {\n    type Lasso = LassoHandler;\n    let Lasso: typeof LassoHandler;\n\n    let lasso: (...args: ConstructorParameters<typeof LassoHandler>) => LassoHandler;\n    \n    namespace Control {\n        type Lasso = LassoControl;\n        let Lasso: typeof LassoControl;\n    }\n\n    namespace control {\n        let lasso: (...args: ConstructorParameters<typeof LassoControl>) => LassoControl;\n    }\n}\n\nif (typeof window.L !== 'undefined') {\n    window.L.Lasso = LassoHandler;\n    window.L.lasso = (...args: ConstructorParameters<typeof LassoHandler>) => new LassoHandler(...args);\n\n    window.L.Control.Lasso = LassoControl;\n    window.L.control.lasso = (...args: ConstructorParameters<typeof LassoControl>) => new LassoControl(...args);\n}\n\nexport * from './lasso-handler';\nexport * from './lasso-control';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}